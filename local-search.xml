<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Activity启动过程源码分析（Android 8.0）</title>
    <link href="/2019/12/07/ActivityStart/"/>
    <url>/2019/12/07/ActivityStart/</url>
    
    <content type="html"><![CDATA[<p>Activity启动过程源码分析（Android 8.0）</p><a id="more"></a><h1 id="Activity启动过程源码分析"><a href="#Activity启动过程源码分析" class="headerlink" title="Activity启动过程源码分析"></a>Activity启动过程源码分析</h1><p>本文来Activity的启动流程，一般我们都是通过startActivity或startActivityForResult来启动目标activity，那么我们就由此出发探究系统是如何实现目标activity的启动的。</p><pre><code>startActivity(new Intent(context, MainActivity.class));startActivityForResult(new Intent(context, SecondActivity.class),1000);</code></pre><p>一般我们都是通过上面两个函数来启动目标activity，我们来看下startActivity的源码</p><blockquote><p>Activity：</p></blockquote><pre><code>@Overridepublic void startActivity(Intent intent) {    this.startActivity(intent, null);}@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) {    if (options != null) {        startActivityForResult(intent, -1, options);    } else {        // Note we want to go through this call for compatibility with&gt;         // applications that may have overridden the method.        startActivityForResult(intent, -1);    }}</code></pre><p>我们可以看到startActivity其实也是调用startActivityForResult来启动目标activity只不过此时requestcode为-1.</p><blockquote><p>Activity：</p></blockquote><pre><code>public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {    startActivityForResult(intent, requestCode, null);}public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,        @Nullable Bundle options) {    if (mParent == null) {        options = transferSpringboardActivityOptions(options);        Instrumentation.ActivityResult ar =            mInstrumentation.execStartActivity(                this, mMainThread.getApplicationThread(), mToken, this,                intent, requestCode, options);//1调用Instrumentation.execStartActivity        if (ar != null) {            mMainThread.sendActivityResult(                mToken, mEmbeddedID, requestCode, ar.getResultCode(),                ar.getResultData());//2发送请求结果        }        if (requestCode &gt;= 0) {            // If this start is requesting a result, we can avoid making            // the activity visible until the result is received.  Setting            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the            // activity hidden during this time, to avoid flickering.            // This can only be done when a result is requested because            // that guarantees we will get information back when the            // activity is finished, no matter what happens to it.            mStartedActivity = true;        }        cancelInputsAndStartExitTransition(options);        // TODO Consider clearing/flushing other event sources and events for child windows.    } else {        if (options != null) {            mParent.startActivityFromChild(this, intent, requestCode, options);        } else {            // Note we want to go through this method for compatibility with            // existing applications that may have overridden it.            mParent.startActivityFromChild(this, intent, requestCode);        }    }}</code></pre><p>在startActivityForResult中会先在注释1处调用Instrumentation.execStartActivity来获取一个ActivityResult实例，ActivityResult是用来描述目标activity执行结果的。由此我们可知activity的启动肯定跟Instrumentation.execStartActivity有关。在注释2处会调用ActivityThread.sendActivityResult来把启动结果发送出去，其最终是通过handler发送一个<em>SEND_RESULT</em> message，这里就不展开详述了有兴趣的自行研究。<br>这里解释几个类概念：<br>ActivityThread：它App的真正入口，当App启动后，会调用其main方法开始执行，开启消息循环队列。是传说中的UI线程，即主线程。与ActivityManagerService配合，一起完成Activity的管理工作；<br>Instrumentation：每一个应用程序都只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或者打开某个Activity时，都需要通过Instrumentation来进行具体的操作</p><p>下面看下Instrumentation.execStartActivity</p><blockquote><p>Instrumentation：</p></blockquote><pre><code>public ActivityResult execStartActivity(        Context who, IBinder contextThread, IBinder token, String resultWho,        Intent intent, int requestCode, Bundle options, UserHandle user) {    IApplicationThread whoThread = (IApplicationThread) contextThread;    //...    try {        intent.migrateExtraStreamToClipData();        intent.prepareToLeaveProcess(who);        //1 调用AMS的startActivity        int result = ActivityManager.getService()            .startActivity(whoThread, who.getBasePackageName(), intent,                    intent.resolveTypeIfNeeded(who.getContentResolver()),                    token, resultWho,                    requestCode, 0, null, options, user.getIdentifier());        checkStartActivityResult(result, intent);    } catch (RemoteException e) {        throw new RuntimeException(&quot;Failure from system&quot;, e);    }    return null;}</code></pre><p>注释1处首先调用了ActivityManager的getService()。</p><blockquote><p>ActivityManager</p></blockquote><pre><code>public static IActivityManager getService() {    return IActivityManagerSingleton.get();}private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =        new Singleton&lt;IActivityManager&gt;() {            @Override            protected IActivityManager create() {                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                final IActivityManager am = IActivityManager.Stub.asInterface(b);                return am;            }        };</code></pre><p>getService()在内部调用了IActivityManagerSingleton.get()，在get（）中先通过ServiceManager.getService获取一个AMS的binder，然后调用IActivityManager.Stub.asInterface。这些操作的作用就是使用AIDL进行IPC（进程间通信）与AMS进行通信。（注意7.0及以前版本IPC的流程是：（客户端）ActivityManagerProxy -&gt; Binder驱动 -&gt; （服务端）ActivityManagerService，而8.0之后变为通过aidl进行IPC）</p><p>通过ActivityManager.getService()就可以拿到AMS的代理，然后调用了AMS的startActivity</p><blockquote><p>ActivityManagerService</p></blockquote><pre><code>public final int startActivity(IApplicationThread caller, String callingPackage,        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,            resultWho, requestCode, startFlags, profilerInfo, bOptions,            UserHandle.getCallingUserId());}public final int startActivityAsUser(IApplicationThread caller, String callingPackage,        Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,        int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {    enforceNotIsolatedCaller(&quot;startActivity&quot;);    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),            userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);    // TODO: Switch to user app stacks here.    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,            profilerInfo, null, null, bOptions, false, userId, null, &quot;startActivityAsUser&quot;);}</code></pre><p>startActivity调用了startActivityAsUser，startActivityAsUser又调用了ActivityStarter.startActivityMayWait，这里解释下ActivityStarter的作用。</p><p>ActivityStarter：启动Activity的控制器，主要用于用来将Intent和flags转换成activity和相关任务栈；</p><blockquote><p>ActivityStarter：</p></blockquote><pre><code>final int startActivityMayWait(IApplicationThread caller, int callingUid,        String callingPackage, Intent intent, String resolvedType,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        IBinder resultTo, String resultWho, int requestCode, int startFlags,        ProfilerInfo profilerInfo, WaitResult outResult,        Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,        TaskRecord inTask, String reason) {//...//1int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,        aInfo, rInfo, voiceSession, voiceInteractor,        resultTo, resultWho, requestCode, callingPid,        callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,        options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,        reason);//...}int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,        ActivityRecord[] outActivity, TaskRecord inTask, String reason) {//...mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,        aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,        callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,        options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,        inTask);//...}private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,        String callingPackage, int realCallingPid, int realCallingUid, int startFlags,        ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,        ActivityRecord[] outActivity, TaskRecord inTask) {//...doPendingActivityLaunchesLocked(false);return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,        options, inTask, outActivity);}private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,        ActivityRecord[] outActivity) {//...//1result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,        startFlags, doResume, options, inTask, outActivity);//...}private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,        int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,        ActivityRecord[] outActivity) {//...mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,        mOptions);//...}</code></pre><p>在注释1处调用startActivityLocked然后经过一系列的调用（startActivityMayWait—&gt; startActivityLocked—-&gt;startActivity —-&gt;startActivity —&gt; startActivityUnchecked—-&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked）最终走到ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</p><p>ActivityStackSupervisor:主要管理着mHomeStack和mFocusedStack两个ActivityStack等相关信息；</p><blockquote><p>ActivityStackSupervisor：</p></blockquote><pre><code>boolean resumeFocusedStackTopActivityLocked(        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {    if (!readyToResume()) {        return false;    }    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);    }    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();    if (r == null || r.state != RESUMED) {        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);    } else if (r.state == RESUMED) {        // Kick off any lingering app transitions form the MoveTaskToFront operation.        mFocusedStack.executeAppTransition(targetOptions);    }    return false;}</code></pre><p>resumeFocusedStackTopActivityLocked内部又调用了ActivityStack.resumeTopActivityUncheckedLocked</p><p>ActivityStack:Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系、状态信息等。通过ActivityStack决定是否需要启动新的进程</p><blockquote><p>ActivityStack:</p></blockquote><pre><code>boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {//...result = resumeTopActivityInnerLocked(prev, options);//...}private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {//...    if (mResumedActivity != null) {        //同步等待pause当前Activity的结果        pausing |= startPausingLocked(userLeaving, false, next, false);    }//...}</code></pre><p>由此我们知道启动新的activity，需要先把当前activity pause。</p><blockquote><p>ActivityStack:</p></blockquote><pre><code>final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean pauseImmediately) {    //....    //去当前Activity所在应用进程暂停当前activity。     prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,            userLeaving, prev.configChangeFlags, pauseImmediately);    //....}</code></pre><p>此处的prev.app.thread实际是ApplicationThread<br>它的作用是完成AMS与ActivityThread之间的通信，ApplicationThread本身是ActivityThread的一个内部类。</p><blockquote><p>ActivityThread$ApplicationThread：</p></blockquote><pre><code>public final void schedulePauseActivity(IBinder token, boolean finished,        boolean userLeaving, int configChanges, boolean dontReport) {    int seq = getLifecycleSeq();    if (DEBUG_ORDER) Slog.d(TAG, &quot;pauseActivity &quot; + ActivityThread.this            + &quot; operation received seq: &quot; + seq);    sendMessage(            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,            token,            (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0),            configChanges,            seq);}</code></pre><p>内部发送了一条message，消息的发送和处理是在H类中，H是handler的子类且它是ActivityThread的一个内部类。</p><blockquote><p>ActivityThread$H:</p></blockquote><pre><code>public void handleMessage(Message msg) {   //...    switch (msg.what) {    case PAUSE_ACTIVITY:        {            SomeArgs args = (SomeArgs) msg.obj;            handlePauseActivity((IBinder) args.arg1, false, (args.argi1 &amp; USER_LEAVING) != 0,            args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3);        }        break;    }    //...}</code></pre><p>在H中调用了handlePauseActivity方法。</p><blockquote><p>ActivityThread:</p></blockquote><pre><code>private void handlePauseActivity(IBinder token, boolean finished,        boolean userLeaving, int configChanges, boolean dontReport, int seq) {//...performPauseActivity(token, finished, r.isPreHoneycomb(), &quot;handlePauseActivity&quot;);//执行pause// Make sure any pending writes are now committed.if (r.isPreHoneycomb()) {    QueuedWork.waitToFinish();}// Tell the activity manager we have paused.if (!dontReport) {    try {        ActivityManager.getService().activityPaused(token);//执行完后通知AMS当前Activity已经pause    } catch (RemoteException ex) {        throw ex.rethrowFromSystemServer();    }}}final Bundle performPauseActivity(IBinder token, boolean finished,        boolean saveState, String reason) {    ActivityClientRecord r = mActivities.get(token);    return r != null ? performPauseActivity(r, finished, saveState, reason) : null;}final Bundle performPauseActivity(ActivityClientRecord r, boolean finished,        boolean saveState, String reason) {//...// Next have the activity save its current state and managed dialogs...if (!r.activity.mFinished &amp;&amp; saveState) {    callCallActivityOnSaveInstanceState(r);}performPauseActivityIfNeeded(r, reason);//执行pause//...}private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) {//...mInstrumentation.callActivityOnPause(r.activity);//...}</code></pre><p>handlePauseActivity内部会先去执行pause操作，执行完毕后会通知AMS。pause的执行经过一系列的调用最终调用了Instrumentation.callActivityOnPause</p><blockquote><p>Instrumentation：</p></blockquote><pre><code>public void callActivityOnPause(Activity activity) {    activity.performPause();}final void performPause() {    mDoReportFullyDrawn = false;    mFragments.dispatchPause();    mCalled = false;    onPause();//调用activity的生命周期函数onPause()    mResumed = false;    if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) {        throw new SuperNotCalledException(                &quot;Activity &quot; + mComponent.toShortString() +                &quot; did not call through to super.onPause()&quot;);    }    mResumed = false;}</code></pre><p>至此当前activity处于onPause状态。</p><p>在handlePauseActivity方法中pause操作后通知了AMS ，调用ActivityManager.getService().activityPaused</p><blockquote><p>ActivityManagerService：</p></blockquote><pre><code>public final void activityPaused(IBinder token) {    final long origId = Binder.clearCallingIdentity();    synchronized(this) {        ActivityStack stack = ActivityRecord.getStackLocked(token);        if (stack != null) {            stack.activityPausedLocked(token, false);//1        }    }    Binder.restoreCallingIdentity(origId);}</code></pre><p>在注释1处调用了ActivityStack得activityPausedLocked</p><blockquote><p>ActivityStack：</p></blockquote><pre><code>final void activityPausedLocked(IBinder token, boolean timeout) {    if (DEBUG_PAUSE) Slog.v(TAG_PAUSE,        &quot;Activity paused: token=&quot; + token + &quot;, timeout=&quot; + timeout);    final ActivityRecord r = isInStackLocked(token);    if (r != null) {        mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r);        if (mPausingActivity == r) {            if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r                    + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;));            mService.mWindowManager.deferSurfaceLayout();            try {                completePauseLocked(true /* resumeNext */, null /* resumingActivity */);//1 pause完成            } finally {                mService.mWindowManager.continueSurfaceLayout();            }            return;        }//...}private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) {//...mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null);//...}</code></pre><p>调用StackSupervisor.resumeFocusedStackTopActivityLocked</p><blockquote><p>StackSupervisor：</p></blockquote><pre><code>boolean resumeFocusedStackTopActivityLocked(        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {    if (!readyToResume()) {        return false;    }/如果启动Activity和要启动的Activity在同一个ActivityStack中，调用targetStack对象的方法    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);    }    final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); //如果不在同一个ActivityStack中，则调用mFocusStack对象的方法    if (r == null || r.state != RESUMED) {        mFocusedStack.resumeTopActivityUncheckedLocked(null, null);    } else if (r.state == RESUMED) {        // Kick off any lingering app transitions form the MoveTaskToFront operation.        mFocusedStack.executeAppTransition(targetOptions);    }    return false;}</code></pre><blockquote><p>ActivityStack：</p></blockquote><pre><code>boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {//...result = resumeTopActivityInnerLocked(prev, options);//...}private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {//...if (mResumedActivity != null) {    //又回到此处 但是因为之前pause时已经将mResumedActivity置null,所以不会再次调用startPausingLocked    pausing |= startPausingLocked(userLeaving, false, next, false);}//...//启动目标activitymStackSupervisor.startSpecificActivityLocked(next, true, true);//...}</code></pre><p>第二次来到resumeTopActivityUncheckedLocked函数，与上次不同的是这次已经完成了pause操作，所以会走到下面StackSupervisor.startSpecificActivityLocked处来启动目标activity。</p><blockquote><p>StackSupervisor：</p></blockquote><pre><code>void startSpecificActivityLocked(ActivityRecord r,        boolean andResume, boolean checkConfig) {//...realStartActivityLocked(r, app, andResume, checkConfig);//...}final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,        boolean andResume, boolean checkConfig) throws RemoteException {//...app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,        System.identityHashCode(r), r.info,        // TODO: Have this take the merged configuration instead of separate global        // and override configs.        mergedConfiguration.getGlobalConfiguration(),        mergedConfiguration.getOverrideConfiguration(), r.compat,        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,        r.persistentState, results, newIntents, !andResume,        mService.isNextTransitionForward(), profilerInfo);//...}</code></pre><p>可以看到最后走到了ActivityThread.scheduleLaunchActivity</p><blockquote><p>ActivityThread：</p></blockquote><pre><code>public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,        int procState, Bundle state, PersistableBundle persistentState,        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,        boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {//...sendMessage(H.LAUNCH_ACTIVITY, r);}</code></pre><p>又回到了H类，我们直接看下H的handleMessage方法</p><blockquote><p>ActivityThread$H:</p></blockquote><pre><code>public void handleMessage(Message msg) {    switch (msg.what) {        case LAUNCH_ACTIVITY: {            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;            r.packageInfo = getPackageInfoNoCheck(                    r.activityInfo.applicationInfo, r.compatInfo);            handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        } break;}private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {//...Activity a = performLaunchActivity(r, customIntent);//...}private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {//...ContextImpl appContext = createBaseContextForActivity(r);//1 创建activity的BaseContextActivity activity = null;try {    java.lang.ClassLoader cl = appContext.getClassLoader();    activity = mInstrumentation.newActivity(            cl, component.getClassName(), r.intent);//2 创建activity    StrictMode.incrementExpectedActivityCount(activity.getClass());    r.intent.setExtrasClassLoader(cl);    r.intent.prepareToEnterProcess();    if (r.state != null) {        r.state.setClassLoader(cl);    }}//...Application app = r.packageInfo.makeApplication(false, mInstrumentation);//3 创建Application//...appContext.setOuterContext(activity);activity.attach(appContext, this, getInstrumentation(), r.token,        r.ident, app, r.intent, r.activityInfo, title, r.parent,        r.embeddedID, r.lastNonConfigurationInstances, config,        r.referrer, r.voiceInteractor, window, r.configCallback);//4 调用attach//...mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);//5 调用生命周期函数OnCreate//...}</code></pre><p>H收到消息后调用了handleLaunchActivity方法，该方法还是比较重要的我们分析下有用的信息。<br>首先在注释1处创建了activity的BaseContext，具体细节参考<a href="https://www.cnblogs.com/Robin132929/p/12061519.html" target="_blank" rel="noopener">Contex知识详解</a><br>在注释2处则通过Instrumentation构造了activity实例，具体来说就是通过ClassLoader去的newInstance来创建的。<br>注释3处则获取了当前应用的Application，需要注意的是如果当前应用尚未创建Application那么此操作会创建Application并返回，如果已经创建则会返回已创建的Application。<br>注释4处调用了attach<br>注释5则是用来回调生命周期函数OnCreate，具体过程如下：</p><blockquote><p>Instrumentation:</p></blockquote><pre><code>public void callActivityOnCreate(Activity activity, Bundle icicle,        PersistableBundle persistentState) {    prePerformCreate(activity);    activity.performCreate(icicle, persistentState);//1    postPerformCreate(activity);}final void performCreate(Bundle icicle, PersistableBundle persistentState) {    mCanEnterPictureInPicture = true;    restoreHasCurrentPermissionRequest(icicle);    if (persistentState != null) {        onCreate(icicle, persistentState);    } else {        onCreate(icicle);//回调onCreate    }    mActivityTransitionState.readState(icicle);    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(            com.android.internal.R.styleable.Window_windowNoDisplay, false);    mFragments.dispatchActivityCreated();    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());}</code></pre><p>至此目标activity就启动完成了，我们可以在onCreate中做相应的初始化操作。</p><p>纵观整个流程可以看出，启动过程经过多次调用涉及到了不少类并且整个流程也甚是复杂繁琐，所以我们有必要在分析完流程后总结一下，这可以帮我们从宏观上对整体流程认识更加深刻。</p><p>首先我们来回顾下整个流程涉及的类以及其作用：</p><ul><li><p>Instrumentation：每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</p></li><li><p>ActivityManagerService： Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作</p></li><li><p>ActivityManager：该类提供与Activity、Service和Process相关的信息以及交互方法， 可以被看作是ActivityManagerService的辅助类</p></li><li><p>ActivityThread：App的真正入口，当App启动后，会调用其main方法开始执行，开启消息循环队列。是传说中的UI线程，即主线程。与ActivityManagerService配合，一起完成Activity的管理工作；</p></li><li><p>ApplicationThread：用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期，通过ApplicationThread的代理对象与ActivityThread通讯；</p></li><li><p>ActvitityStack：Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系、状态信息等。通过ActivityStack决定是否需要启动新的进程；</p></li><li><p>ActivityRecord：ActivityStatck的管理对象，每个Activity在AMS对应的一个ActivityRecord，来记录Activity的状态以及其他信息。可以理解为Activity在服务端的Activity对象的映射；</p></li><li><p>TaskRecord：AMS抽象出来的任务栈的概念。一个TaskRecord包含若干个ActivityRecord。ASM用它来确保Activity启动和退出顺序。它与Activity的启动模式直接相关。</p></li><li><p>ActivityStarter：启动Activity的控制器，主要用于用来将Intent和flags转换成activity和相关任务栈；</p></li><li><p>ActivityStackSupervisor：负责所有Activity栈的管理。内部管理了mHomeStack、mFocusedStack和mLastFocusedStack三个Activity栈。其中，mHomeStack管理的是Launcher相关的Activity栈；mFocusedStack管理的是当前显示在前台Activity的Activity栈；mLastFocusedStack管理的是上一次显示在前台Activity的Activity栈。</p></li></ul><p>对于以上类我们要熟悉其作用。</p><p>接下来就是启动流程的总结了：（此处以 A启动B为例）<br>1、Activity A通过startActivity等函数启动B<br>2、步骤1调用之后当前应用会向AMS发送一个启动Activity B的进程间通信请求；<br>3、AMS会将要启动的Activity B的组件信息保存下来，ActivityManagerService接收到启动请求后会进行必要的初始化以及状态的刷新，然后解析Activity的启动模式，为启动Activity做一系列的准备工作。</p><p>4、然后判断栈顶是否为空，如果不为空即当前有Activity A显示在前台，则会先进行栈顶Activity的onPause流程，此过程是通过Binder通信（ApplicationThread及其接口定义语言）完成<br>5、Activity A完成pause操作后，通过Binder通信（ActivityManagerService及其接口定义语言）通知AMS，可以执行启动Activity B的操作了（要启动的activity信息保存在了栈顶）（此处需要注意的是如果Activity被启动过则直接执行onRestart-&gt;onStart-&gt;onResume过程直接启动Activity（热启动过程）。否则执行Activity所在应用的冷启动过程。冷启动的过程是通过Zygote进程fork出一个新的进程然后执行ActivityThread的main方法启动新进程）<br>6、上述步骤完成后AMS执行一系列启动Activity B的操作，并通过Binder通信（ApplicationThread及其接口定义语言）进行跨进程调用，将Activity B启动起来；</p><p>参考：<br><a href="https://www.jianshu.com/p/6719238ae5f0" target="_blank" rel="noopener">Android Activity启动流程(基于Android8.0系统)</a><br><a href="https://www.jianshu.com/p/89fd44083c1c" target="_blank" rel="noopener">Activity启动流程源码分析</a><br><a href="https://www.jianshu.com/p/2bed70245c76" target="_blank" rel="noopener">Activity启动流程简直丧心病狂！</a><br><a href="https://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">Activity启动过程全解析</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android系统启动过程分析</title>
    <link href="/2019/12/05/androidstart/"/>
    <url>/2019/12/05/androidstart/</url>
    
    <content type="html"><![CDATA[<p>Android系统(8.0)启动过程分析</p><a id="more"></a><h1 id="Android系统启动过程分析"><a href="#Android系统启动过程分析" class="headerlink" title="Android系统启动过程分析"></a>Android系统启动过程分析</h1><h2 id="一、Android平台架构"><a href="#一、Android平台架构" class="headerlink" title="一、Android平台架构"></a>一、Android平台架构</h2><p>首先贴一张Android系统架构图方便理解整个Android架构，这可以让我们从整体上对整个启动流程有个大概认知。</p><p><img src="https://img-blog.csdn.net/20170123173332254?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRhY2hpODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="/img/loading.gif" alt="Android系统架构图"></p><p>可以看出整个架构由5部分构成，从下到上分别为：<br>     1. Linux内核层<br>Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。<br>    2. 硬件抽象层（HAL)<br>硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 HAL 由多个库模块组成，每个模块都为特定类型的硬件组件实现了一个接口，例如相机或蓝牙模块。 当框架 API 调用设备硬件时，Android 系统为该硬件组件加载库模块。<br>     3. 系统运行库层（Native)<br>系统运行库层分为两部分，分别是C/C++程序库和Android运行时库。 C/C++程序库被Android中不同的部分使用 runtime库主要是Java核心库（提供了Java语言核心功能因此开发者可以使用Java编写应用）和ART（Android 5.0 之前是Dalvik）该虚拟机不同于JVM是专门用于移动设备的虚拟机 允许在有限的内存内运行多个虚拟机实例 并且每个应用都是独立的linux进程这样可以防止虚拟机崩溃时不会导致所有的进程被关闭。ART和Dalvik的区别是 后者在应用每次启动时才会通过即时编译把字节码转化为机器码 （这会影响应用运行效率）ART则是在应用第一次安装的时候就会把字节码文件转换为机器码 这样虽然会在安装时耗时增加 但app每次启动的时间会减少<br>    4. 应用框架层（Java Framework)<br>应用框架层为开发人员提供了可以开发应用程序所需要的API，我们平常开发应用程序都是调用的这一层所提供的API，当然也包括系统的应用。这一层的是由Java代码编写的，可以称为Java Framework<br>该层包含以下内容：</p><ul><li>一个丰富和可扩展的视图系统</li><li>Resource Manager</li><li>Notification Manager</li><li>Activity Manager</li><li>Content Providers<ol start="5"><li>应用层<br>系统内置的应用程序以及非系统级的应用程序都是属于应用层。负责与用户进行直接交互，通常都是用Java进行开发的</li></ol></li></ul><h2 id="二、Android系统的启动流程"><a href="#二、Android系统的启动流程" class="headerlink" title="二、Android系统的启动流程"></a>二、Android系统的启动流程</h2><p>Android系统的启动流程大致分为三个阶段：</p><ol><li>电源键按下后加载引导程序Bootloader到RAM 然后Bootloader把OS拉起</li><li>Linux 内核层面的启动</li><li>Android系统层面的启动</li></ol><blockquote><p><strong>本文主要分析Android系统层面的启动</strong></p></blockquote><h3 id="一、Bootloader的加载"><a href="#一、Bootloader的加载" class="headerlink" title="一、Bootloader的加载"></a>一、Bootloader的加载</h3><p>当电源键被按下后会去加载Bootloader，这个程序会把OS拉活，然后就会进入OS的启动过程。</p><h3 id="二、Linux内核的启动"><a href="#二、Linux内核的启动" class="headerlink" title="二、Linux内核的启动"></a>二、Linux内核的启动</h3><p>Android底层是基于Linux内核的并做了一些扩展，添加一些驱动比如binder。Linux内核的启动流程是先启动idle线程（整个Linux系统的初始线程 pid=0）然后idle线程会启动init和kthread线程。init线程是负责启动Android系统并且是Android系统其他进程的父进程。kthread线程则负责创建并管理Linux系统内核线程。</p><p><strong>1、ildle进程</strong></p><p>主要是完成Linux系统的启动然后完成一些初始化任务之后会进入一个死循环，不断判断是否有新的进程需要启动如果没有则会让cpu和系统时钟进入休眠状态 当有新进程需要创建时在唤醒cpu</p><p><strong>2、kthread进程</strong></p><p>主要负责创建Linux系统内核相关线程 并始终运行在内核线程中 作为内核线程中其他线程的父类 负责内核线程的调度和管理</p><p><strong>3、init进程</strong></p><p>它是Linux系统第一个用户进程，主要工作分为两部分。首先会完成内核的创建和初始化这部分内容跟Linux内核相关， 其次就是用户空间的创建和启动这部分内容跟Android系统的启动相关</p><p>init进程第一阶段做的主要工作是挂载分区,创建设备节点和一些关键目录,初始化日志输出系统,启用SELinux安全策略</p><p>init进程第二阶段主要工作是初始化属性系统，解析SELinux的匹配规则，处理子进程终止信号，启动系统属性服务，可以说每一项都很关键，如果说第一阶段是为属性系统，SELinux做准备，那么第二阶段就是真正去把这些落实的。</p><p>其实init进程在完成第二阶段工作的时候就已经涉及到Android系统层面的启动了 因为init进程会去加载init.rc配置文件然后启动Zygote进程。<br>Init的启动入口是在其main函数中</p><pre><code>int main(int argc, char** argv) {    ......    bool is_first_stage = (getenv(&quot;INIT_SECOND_STAGE&quot;) == nullptr);    if (is_first_stage) {        boot_clock::time_point start_time = boot_clock::now();        umask(0);        //创建和挂载启动所需要的文件目录        mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);        mkdir(&quot;/dev/pts&quot;, 0755);        mkdir(&quot;/dev/socket&quot;, 0755);        mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);        #define MAKE_STR(x) __STRING(x)        mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));        chmod(&quot;/proc/cmdline&quot;, 0440);        gid_t groups[] = { AID_READPROC };        setgroups(arraysize(groups), groups);        mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL);        mount(&quot;selinuxfs&quot;, &quot;/sys/fs/selinux&quot;, &quot;selinuxfs&quot;, 0, NULL);        mknod(&quot;/dev/kmsg&quot;, S_IFCHR | 0600, makedev(1, 11));        mknod(&quot;/dev/random&quot;, S_IFCHR | 0666, makedev(1, 8));        mknod(&quot;/dev/urandom&quot;, S_IFCHR | 0666, makedev(1, 9));        ......       // Set up SELinux, loading the SELinux policy.启动SELinux        selinux_initialize(true);        ......    }    ......    //对属性服务进行初始化    property_init();    ......    epoll_fd = epoll_create1(EPOLL_CLOEXEC);    if (epoll_fd == -1) {        PLOG(ERROR) &lt;&lt; &quot;epoll_create1 failed&quot;;        exit(1);    }    //用于设置子进程信号处理函数，如果子进程异常退出，init进程会调用该函     //数中设置的信号处理函数进行处理。    signal_handler_init();    ......    //启动属性服务    start_property_service();    ......    if (bootscript.empty()) {        //解析init.rc配置文件        parser.ParseConfig(&quot;/init.rc&quot;);        parser.set_is_system_etc_init_loaded(                parser.ParseConfig(&quot;/system/etc/init&quot;));        parser.set_is_vendor_etc_init_loaded(                parser.ParseConfig(&quot;/vendor/etc/init&quot;));        parser.set_is_odm_etc_init_loaded(parser.ParseConfig(&quot;/odm/etc/init&quot;));    }     ......    while (true) {        ......        if (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) {            am.ExecuteOneCommand();        }        if (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) {            //重启死去的服务            restart_processes();        }        ......    }    return 0;}</code></pre><p>我们注意下init.rc文件，它的路径为：system/core/rootdir/init.rc。它是一个非常重要的配置文件，是由Android初始化语言编写的脚本。Android8.0对该文件进行来拆分，每个服务对应一个rc文件，启动<strong>Zygote</strong>的脚本在init.zygoteXX.rc中定义，代表多少位处理器。这里以64位为例。</p><pre><code>service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server    class main    priority -20    user root    group root readproc    socket zygote stream 660 root system    onrestart write /sys/android_power/request_state wake    onrestart write /sys/power/state on    onrestart restart audioserver    onrestart restart cameraserver    onrestart restart media    onrestart restart netd    onrestart restart wificond    writepid /dev/cpuset/foreground/tasks</code></pre><p>我们只需要知道上面的命令就是创建名为<strong>zygote</strong>的进程即可。实际创建是通过app_process64完成的，对应的文件为app_main.cpp，创建完成后会调用zygote的mian函数。</p><pre><code>int main(int argc, char* const argv[]){...    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));//1... // Parse runtime arguments.  Stop at first unrecognized option.    bool zygote = false;    bool startSystemServer = false;    bool application = false;    String8 niceName;    String8 className;    ++i;  // Skip unused &quot;parent dir&quot; argument.    while (i &lt; argc) {        const char* arg = argv[i++];        if (strcmp(arg, &quot;--zygote&quot;) == 0) {            zygote = true;//2            niceName = ZYGOTE_NICE_NAME;        } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) {            startSystemServer = true;        } else if (strcmp(arg, &quot;--application&quot;) == 0) {            application = true;        } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) {            niceName.setTo(arg + 12);        } else if (strncmp(arg, &quot;--&quot;, 2) != 0) {            className.setTo(arg);            break;        } else {            --i;            break;        }    }... if (zygote) {        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);//3    } else if (className) {        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);    } else {        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);        app_usage();        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);    }</code></pre><p>首先在注释1处声明了一个AppRuntime类型的runtime，然后在注释2处将zygote置为true，最后在注释3处用runtime.start（）启动zygote。</p><h3 id="三、Android-系统的启动"><a href="#三、Android-系统的启动" class="headerlink" title="三、Android 系统的启动"></a>三、Android 系统的启动</h3><p>之前我们跟踪到zygote进程的启动，zygote可以看做是Android系统所有进程的父进程，DVM和ART、应用程序进程以及运行系统的关键服务SystemServer进程都是由Zygote进程通过fork创建的。Zygote预加载初始化核心库类，让DVM和ART虚拟机共享代码、降低内存占用和启动时间，因此只要Zygote装载好了这些类和资源后，新的进程就不需要在装载这些类和资源了，它们共享Zygote进程的资源和类。</p><p>那接下来我们看下AppRuntime的start方法<br>frameworks/base/core/jni/AndroidRuntime.cpp</p><pre><code>void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){... /* start the virtual machine */    JniInvocation jni_invocation;    jni_invocation.Init(NULL);    JNIEnv* env;    //1 启动Java虚拟机    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) {        return;    }    onVmCreated(env);    /*     * Register android functions.     *     */    if (startReg(env) &lt; 0) {//2 注册jni方法        ALOGE(&quot;Unable to register all android natives\n&quot;);        return;    }/*     * We want to call main() with a String array with arguments in it.     * At present we have two arguments, the class name and an option string.     * Create an array to hold them.     */    jclass stringClass;    jobjectArray strArray;    jstring classNameStr;    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);    assert(stringClass != NULL);    strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);    assert(strArray != NULL); //从app_main传过来的参数classname值为：“com.android.internal.os.ZygoteInit”    classNameStr = env-&gt;NewStringUTF(className);    assert(classNameStr != NULL);    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);    for (size_t i = 0; i &lt; options.size(); ++i) {        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());        assert(optionsStr != NULL);        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);    }    /*     * Start VM.  This thread becomes the main thread of the VM, and will     * not return until the VM exits.     */    char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;);    jclass startClass = env-&gt;FindClass(slashClassName);    if (startClass == NULL) {        ALOGE(&quot;JavaVM unable to locate class &#39;%s&#39;\n&quot;, slashClassName);        /* keep going */    } else {        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,            &quot;([Ljava/lang/String;)V&quot;);//3 找到ZygoteInit的main函数，该函数是要启动的函数        if (startMeth == NULL) {            ALOGE(&quot;JavaVM unable to find main() in &#39;%s&#39;\n&quot;, className);            /* keep going */        } else {            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);//4 通过Jni调用ZygoteInit的main函数#if 0            if (env-&gt;ExceptionCheck())                threadExitUncaughtException(env);#endif        }    }</code></pre><p>在start方法中我们看到先是在注释1处启动虚拟机然后在注释2处注册jni.之后就是通过传入的类名找到要启动的class最终在注释3处将其赋值给startMeth（此时表示要启动ZygoteInit的main函数），最终的启动是在注释4处。</p><p>我们看下ZygoteInit的main函数</p><pre><code>   public static void main(String argv[]) {   ...           ZygoteServer zygoteServer = new ZygoteServer();//1 构造zygoteServer实例...boolean startSystemServer = false;            String socketName = &quot;zygote&quot;;            String abiList = null;            boolean enableLazyPreload = false;            for (int i = 1; i &lt; argv.length; i++) {                if (&quot;start-system-server&quot;.equals(argv[i])) {                    startSystemServer = true;                } else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) {                    enableLazyPreload = true;                } else if (argv[i].startsWith(ABI_LIST_ARG)) {                    abiList = argv[i].substring(ABI_LIST_ARG.length());                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());                } else {                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);                }            }            zygoteServer.registerServerSocket(socketName);//2 注册服务端的scoket             if (startSystemServer) {//通过fork启动SystemServer进程                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);//3                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the                // child (system_server) process.                if (r != null) {                    r.run();//此处调用的run方法是MethodAndArgsCaller类的run 该类是RuntimeInit的一个静态内部类                    return;                }            }            Log.i(TAG, &quot;Accepting command socket connections&quot;);            // The select loop returns early in the child process after a fork and            // loops forever in the zygote.            caller = zygoteServer.runSelectLoop(abiList);//4等待客户端请求 fork进程        } catch (Throwable ex) {            Log.e(TAG, &quot;System zygote died with exception&quot;, ex);            throw ex;        } finally {            zygoteServer.closeServerSocket();        }</code></pre><p>在注释1处构造了一个zygoteServer实例，之后在注释2处注册服务端的scoket，这里scoket的类型是loaclscoket它是Android对Linuxscoket的一种封装。Local Socket 是Linux提供的一种基于Socket的进程间通信方式，对Server端来讲，唯一的区别就是bind到一个本地的文件描述符(fd)而不是某个IP地址和端口号。Android里很多地方用到了Local Socket做进程间的通信。scoket创建完成后就等待用来相应客户端fork的请求，即在注释3处通过fork启动SystemServer进程，在注释4处等待客户端fork进程的请求。</p><p>总结来说ZygoteInit主要做了两件事：<br>1、注册了服务端的scoket<br>2、fork进程 启动SystemServer进程</p><p>此处说下zygoteinit这个类 Android8.0发生了一些改动。之前在main函数会先预加载（preload）一些东西然后注册服务端socket。在8.0版本预加载的操作放在了静态代码块中，下面是preload的静态代码块。preload主要做了两件事   preloadClasses(); preloadResources();<br>preloadClassess 将framework.jar里的preloaded-classes 定义的所有class load到内存里，preloaded-classes 编译Android后可以在framework/base下找到。而preloadResources 将系统的Resource(不是在用户apk里定义的resource）load到内存。</p><p>资源preload到Zygoted的进程地址空间，所有fork的子进程将共享这份空间而无需重新load, 这大大减少了应用程序的启动时间，但反过来增加了系统的启动时间。通过对preload 类和资源数目进行调整可以加快系统启动。</p><pre><code>static void preload(TimingsTraceLog bootTimingsTraceLog) {        Log.d(TAG, &quot;begin preload&quot;);        bootTimingsTraceLog.traceBegin(&quot;BeginIcuCachePinning&quot;);        beginIcuCachePinning();        bootTimingsTraceLog.traceEnd(); // BeginIcuCachePinning        bootTimingsTraceLog.traceBegin(&quot;PreloadClasses&quot;);        preloadClasses();        bootTimingsTraceLog.traceEnd(); // PreloadClasses        bootTimingsTraceLog.traceBegin(&quot;PreloadResources&quot;);        preloadResources();        bootTimingsTraceLog.traceEnd(); // PreloadResources        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadAppProcessHALs&quot;);        nativePreloadAppProcessHALs();        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, &quot;PreloadOpenGL&quot;);        preloadOpenGL();        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);        preloadSharedLibraries();        preloadTextResources();        // Ask the WebViewFactory to do any initialization that must run in the zygote process,        // for memory sharing purposes.        WebViewFactory.prepareWebViewInZygote();        endIcuCachePinning();        warmUpJcaProviders();        Log.d(TAG, &quot;end preload&quot;);        sPreloadComplete = true;    }</code></pre><p>上面我们总结了ZygoteInit会先注册一个五福段的Scoket，我们来看下具体是如何注册的。</p><pre><code>void registerServerSocket(String socketName) {        if (mServerSocket == null) {            int fileDesc;            final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; //1            try {                String env = System.getenv(fullSocketName);                fileDesc = Integer.parseInt(env);            } catch (RuntimeException ex) {                throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);            }            try {                FileDescriptor fd = new FileDescriptor();                fd.setInt$(fileDesc);                mServerSocket = new LocalServerSocket(fd);//2            } catch (IOException ex) {                throw new RuntimeException(                        &quot;Error binding to local socket &#39;&quot; + fileDesc + &quot;&#39;&quot;, ex);            }        }    }</code></pre><p>注释1处的fullSocketName是该scoket的全名，在注释2处new了一个LocalServerSocket实例并传入文件描述符fd最后赋值给mServerSocket，它就是我们启动的scoket。当Zygote进程将SystemServer进程启动后， 就会在这个服务端的Socket上来等待ActivityManagerService请求Zygote进程来创建新的应用程序进程。</p><p>在创建完scoket之后便通过fork方式创建SystemServer进程，具体看main函数的注释3。最后在注释4处调用runSelectLoop函数。先看下注释3处是如何创建SystemServer进程，具体是通过forkSystemServer方法</p><pre><code> private static Runnable forkSystemServer(String abiList, String socketName,            ZygoteServer zygoteServer) {        /* Containers run without this capability, so avoid setting it in that case */        if (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, false)) {            capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);        }        /* Hardcoded command line to start the system server          */        String args[] = {            &quot;--setuid=1000&quot;,            &quot;--setgid=1000&quot;,            &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1032,3001,3002,3003,3006,3007,3009,3010&quot;,            &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,            &quot;--nice-name=system_server&quot;, //代表进程名            &quot;--runtime-args&quot;,            &quot;com.android.server.SystemServer&quot;, //启动的类名        };        ZygoteConnection.Arguments parsedArgs = null;        int pid;        try {            parsedArgs = new ZygoteConnection.Arguments(args);            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);//1//将启动的参数解析成parsedArgs            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);            /* Request to fork the system server process            */            pid = Zygote.forkSystemServer(                    parsedArgs.uid, parsedArgs.gid,                    parsedArgs.gids,                    parsedArgs.debugFlags,                    null,                    parsedArgs.permittedCapabilities,                    parsedArgs.effectiveCapabilities);//2 fork System Server进程        } catch (IllegalArgumentException ex) {            throw new RuntimeException(ex);        }        /* For child process        */        if (pid == 0) {//pid=0代表fork成功 并在子线程中启动system server进程            if (hasSecondZygote(abiList)) {                waitForSecondaryZygote(socketName);            }            zygoteServer.closeServerSocket();            return handleSystemServerProcess(parsedArgs);//3启动system server进程 system server在这个函数进行初始化        }        return null;    }</code></pre><p>首先是构造一个字符串数组来设置用户和用户组id然后在注释1处将其解析成parsedArgs。在注释2处通过fork创建SystemServer进程并传入一些参数<br>启动system server进程，进程的最终创建是通过native方法nativeForkSystemServer完成的。<br>最后在注释3处启动了system server进程。</p><p>接下来看下注释4处的runSelectLoop作用 runSelectLoop函数如下所示</p><pre><code>    Runnable runSelectLoop(String abiList) {        ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();        ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();//mServerSocket 就是之前注册的server scoket ，在这里得到它的fd并放到fd列表中        fds.add(mServerSocket.getFileDescriptor());        peers.add(null);        while (true) {            //遍历Fds列表把其中的信息放到pollFds 中            StructPollfd[] pollFds = new StructPollfd[fds.size()];            for (int i = 0; i &lt; pollFds.length; ++i) {                pollFds[i] = new StructPollfd();                pollFds[i].fd = fds.get(i);                pollFds[i].events = (short) POLLIN;            }            try {                Os.poll(pollFds, -1);            } catch (ErrnoException ex) {                throw new RuntimeException(&quot;poll failed&quot;, ex);            }            for (int i = pollFds.length - 1; i &gt;= 0; --i) {                if ((pollFds[i].revents &amp; POLLIN) == 0) {                    continue;                }//i=0表示服务端Socket与客户端连接上，也就是当前Zygote进程与ActivityManagerService建立了连接                if (i == 0) {                    ZygoteConnection newPeer = acceptCommandPeer(abiList);                    peers.add(newPeer);                    //将ZygoteConnection的fd添加到fds列表中 以便接受AMS发送的创建应用的请求                    fds.add(newPeer.getFileDesciptor());                } else {                    //如果i&gt;0表示有创建新应用进程的请求                    try {                        ZygoteConnection connection = peers.get(i);                        //根据请求创建新的应用进程                        final Runnable command = connection.processOneCommand(this);                        if (mIsForkChild) {                            // We&#39;re in the child. We should always have a command to run at this                            // stage if processOneCommand hasn&#39;t called &quot;exec&quot;.                            if (command == null) {                                throw new IllegalStateException(&quot;command == null&quot;);                            }                            return command;                        } else {                            // We&#39;re in the server - we should never have any commands to run.                            if (command != null) {                                throw new IllegalStateException(&quot;command != null&quot;);                            }                            // We don&#39;t know whether the remote side of the socket was closed or                            // not until we attempt to read from it from processOneCommand. This shows up as                            // a regular POLLIN event in our regular processing loop.                            if (connection.isClosedByPeer()) {                                connection.closeSocket();                                peers.remove(i);                                fds.remove(i);                            }                        }                    } catch (Exception e) {                        if (!mIsForkChild) {                            // We&#39;re in the server so any exception here is one that has taken place                            // pre-fork while processing commands or reading / writing from the                            // control socket. Make a loud noise about any such exceptions so that                            // we know exactly what failed and why.                            Slog.e(TAG, &quot;Exception executing zygote command: &quot;, e);                            // Make sure the socket is closed so that the other end knows immediately                            // that something has gone wrong and doesn&#39;t time out waiting for a                            // response.                            ZygoteConnection conn = peers.remove(i);                            conn.closeSocket();                            fds.remove(i);                        } else {                            // We&#39;re in the child so any exception caught here has happened post                            // fork and before we execute ActivityThread.main (or any other main()                            // method). Log the details of the exception and bring down the process.                            Log.e(TAG, &quot;Caught post-fork exception in child process.&quot;, e);                            throw e;                        }                    }                }            }        }    }</code></pre><p>新进程的创建是通过processOneCommand完成的。下面贴下processOneCommand函数</p><pre><code> Runnable processOneCommand(ZygoteServer zygoteServer) { ...   //创建应用进程        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,                parsedArgs.appDataDir); ...</code></pre><p>Zygote的forkAndSpecialize函数最终是通过native方法完成进程创建。</p><pre><code> int pid = nativeForkAndSpecialize(                  uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,                  fdsToIgnore, instructionSet, appDataDir);</code></pre><hr><p>好了，到此init和zygote进程的创建和启动流程以及它过程中都做了哪些事我们都梳理了一遍。现在简单总结下：<br>1、init进程</p><ul><li>创建一些文件夹并挂载设备 </li><li>初始化和启动属性服务 </li><li>解析init.rc配置文件并启动zygote进程<br>2、zygote进程</li><li>创建VM</li><li>创建并启动system server进程</li></ul><p>zygote启动流程简单总结:首先通过AndroidRunTime.start来启动zygoteinit的main函数，在main函数中通过ZygoteServer注册了scoket并通过runSelectLoop进行监听AMS是否有启动新进程的请求，如果有就通过native方法创建新进程。并且创建了systemserver进程。</p><h4 id="system-server进程的启动"><a href="#system-server进程的启动" class="headerlink" title="system server进程的启动"></a>system server进程的启动</h4><p>我们知道在zygote进程当中创建并启动system server进程。那么接下来我们一起看下system server进程启动过程都干了什么。</p><p>我们知道system server进程的启动是通过handleSystemServerProcess该函数位于com.android.internal.os.ZygoteInit</p><pre><code> private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) { ...        if (parsedArgs.invokeWith != null) {            String[] args = parsedArgs.remainingArgs;            // If we have a non-null system server class path, we&#39;ll have to duplicate the            // existing arguments and append the classpath to it. ART will handle the classpath            // correctly when we exec a new process.            if (systemServerClasspath != null) {                String[] amendedArgs = new String[args.length + 2];                amendedArgs[0] = &quot;-cp&quot;;                amendedArgs[1] = systemServerClasspath;                System.arraycopy(args, 0, amendedArgs, 2, args.length);                args = amendedArgs;            }            WrapperInit.execApplication(parsedArgs.invokeWith,                    parsedArgs.niceName, parsedArgs.targetSdkVersion,                    VMRuntime.getCurrentInstructionSet(), null, args);            throw new IllegalStateException(&quot;Unexpected return from WrapperInit.execApplication&quot;);        } else {            ClassLoader cl = null;            if (systemServerClasspath != null) {                cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);                Thread.currentThread().setContextClassLoader(cl);            }            /*             * Pass the remaining arguments to SystemServer.             */            return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);//1        } }</code></pre><p>可以看出最后调用ZygoteInit.zygoteInit</p><pre><code>public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {        if (RuntimeInit.DEBUG) {            Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);        }        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);        RuntimeInit.redirectLogStreams();        RuntimeInit.commonInit();        ZygoteInit.nativeZygoteInit(); //调用native方法对Zygote进行init        return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); //1    }</code></pre><p>ZygoteInit.zygoteInit调用RuntimeInit.applicationInit</p><pre><code>protected static Runnable applicationInit(int targetSdkVersion, String[] argv,            ClassLoader classLoader) {            ...               nativeSetExitWithoutCleanup(true);        // We want to be fairly aggressive about heap utilization, to avoid        // holding on to a lot of memory that isn&#39;t needed.        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);        final Arguments args = new Arguments(argv);        // The end of of the RuntimeInit event (see #zygoteInit).        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        // Remaining arguments are passed to the start class&#39;s static main        return findStaticMain(args.startClass, args.startArgs, classLoader);//1    }</code></pre><p>RuntimeInit.applicationInit又会调用findStaticMain方法</p><pre><code>    private static Runnable findStaticMain(String className, String[] argv,            ClassLoader classLoader) {        Class&lt;?&gt; cl;        try {            cl = Class.forName(className, true, classLoader);//1        } catch (ClassNotFoundException ex) {            throw new RuntimeException(                    &quot;Missing class when invoking static main &quot; + className,                    ex);        }        Method m;        try {            m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });//2        } catch (NoSuchMethodException ex) {            throw new RuntimeException(                    &quot;Missing static main on &quot; + className, ex);        } catch (SecurityException ex) {            throw new RuntimeException(                    &quot;Problem getting static main on &quot; + className, ex);        }        int modifiers = m.getModifiers();//3        if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {            throw new RuntimeException(                    &quot;Main method is not public and static on &quot; + className);        }        /*         * This throw gets caught in ZygoteInit.main(), which responds         * by invoking the exception&#39;s run() method. This arrangement         * clears up all the stack frames that were required in setting         * up the process.         */        return new MethodAndArgsCaller(m, argv);    }</code></pre><p>注释2处根据传入的类名获取Class对象，注释2处则获取该类的main方法。注释3处获取main方法的修饰判断是否符合要求（必须是pubilc static）最终返回一个MethodAndArgsCaller对象。<br>它是RuntimeInit类的 一个静态内部类并且实现了runnable接口。</p><pre><code> static class MethodAndArgsCaller implements Runnable {        /** method to call */        private final Method mMethod;        /** argument array */        private final String[] mArgs;        public MethodAndArgsCaller(Method method, String[] args) {            mMethod = method;            mArgs = args;        }        public void run() {//1            try {                mMethod.invoke(null, new Object[] { mArgs });//2            } catch (IllegalAccessException ex) {                throw new RuntimeException(ex);            } catch (InvocationTargetException ex) {                Throwable cause = ex.getCause();                if (cause instanceof RuntimeException) {                    throw (RuntimeException) cause;                } else if (cause instanceof Error) {                    throw (Error) cause;                }                throw new RuntimeException(ex);            }        }    }</code></pre><p>首先看下在它的run方法中的注释2处执行了传进来的main方法，这个其实就是SystemServer的main方法。那么还剩一个问题是它的run函数（注释1）在哪里执行的呢？ 你是否还记得ZygoteInit类的main函数中有如下调用</p><pre><code>    public static void main(String argv[]) {... if (startSystemServer) {                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);//创建SystemServer进程                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the                // child (system_server) process.                if (r != null) {                    r.run();//1                    return;                }            }</code></pre><p>我们看forkSystemServer返回了一个runnable对象然后如果它不为空就调用它的run方法。其实这个runnable就是一个MethodAndArgsCaller实例。由此我们就进入到了SystemServer类的main方法中。</p><pre><code>  /**     * The main entry point from zygote.      */    public static void main(String[] args) {        new SystemServer().run();    }</code></pre><p>该main方法非常简单就是调用自身的run方法。</p><pre><code> private void run() {        try {        //手机时间早于1970 会重新设置为1970            if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) {                Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;);                SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);            }... // Prepare the main looper thread (this thread).            android.os.Process.setThreadPriority(                android.os.Process.THREAD_PRIORITY_FOREGROUND);            android.os.Process.setCanSelfBackground(false);            Looper.prepareMainLooper();//1准备主线程looper            // Initialize native services.             System.loadLibrary(&quot;android_servers&quot;);//2初始化native相关服务            // Check whether we failed to shut down last time we tried.            // This call may not return.            performPendingShutdown();            // Initialize the system context.             createSystemContext();//3初始化系统context            // Create the system service manager.             mSystemServiceManager = new SystemServiceManager(mSystemContext);//4创建system service manager            mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);            LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);            // Prepare the thread pool for init tasks that can be parallelized            SystemServerInitThreadPool.get();        } finally {            traceEnd();  // InitBeforeStartServices        }        // Start services.        try {            traceBeginAndSlog(&quot;StartServices&quot;);            //5启动各种服务            startBootstrapServices();            startCoreServices();            startOtherServices();            SystemServerInitThreadPool.shutdown();        } catch (Throwable ex) {            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);            throw ex;        } finally {            traceEnd();        }        ...        // Loop forever.        Looper.loop();//6        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</code></pre><p>run方法信息量还是很大的，先看下注释1处初始化主线程的looper，注释2初始化了native相关服务，注释3初始化system context，注释4创建system service manager，注释5则先后初始化了各种服务，注释6调用了Looper.loop（）。<br>注释3处system context其实最终是返回contextimpl实例。注释4处创建的SystemServiceManager主要是用在稍后初始化各种服务时用来启动的服务的。</p><p>一个Service启动需要的几个步骤：<br>      1. 初始化Service 对象，获得IBinder对象。<br>      2. 启动后台线程，并进入Loop等待。<br>      3. 将自己注册到Service Manager, 让其他进程通过名字可以获得远程调用必须的IBinder的对象。<br>注释5处先后启动了多种系统服务，这些服务分为3类：引导服务、系统服务、其他服务。毫无疑问，这么多服务之间是有依赖关系的，比如说，ActivityManager Service 在WindowManager Service 初始化完成之前是不能启动应用的。那如何控制这些先后顺序的？这里由System server的启动线程通过SystemReady()接口来完成。每个系统服务必须实现一个SystemReady() 接口，当被调用，表明系统已经OK， 该服务可以访问（直接或间接）其他服务的资源。 最后一个被调到的服务就是AcitivyManager Service. AM的SystemReady()。</p><p>系统的启动方式有两种：</p><ul><li><strong>第一种是通过SystemServiceManager.startService启动，下面以PowerManager启动为例：</strong></li></ul><pre><code>  private void startBootstrapServices() {          mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);}</code></pre><pre><code> public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {        try {        try {                Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);                service = constructor.newInstance(mContext);            } catch (InstantiationException ex) {                throw new RuntimeException(&quot;Failed to create service &quot; + name                        + &quot;: service could not be instantiated&quot;, ex);            } catch (IllegalAccessException ex) {                throw new RuntimeException(&quot;Failed to create service &quot; + name                        + &quot;: service must have a public constructor with a Context argument&quot;, ex);            } catch (NoSuchMethodException ex) {                throw new RuntimeException(&quot;Failed to create service &quot; + name                        + &quot;: service must have a public constructor with a Context argument&quot;, ex);            } catch (InvocationTargetException ex) {                throw new RuntimeException(&quot;Failed to create service &quot; + name                        + &quot;: service constructor threw an exception&quot;, ex);            }            startService(service);//1            return service;        } finally {            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);        }</code></pre><p>可以看出首先会用反射得到一个service实例然后调用同名startService方法</p><pre><code>private final ArrayList&lt;SystemService&gt; mServices = new ArrayList&lt;SystemService&gt;(); public void startService(@NonNull final SystemService service) {        // Register it.        mServices.add(service);//1        // Start it.        long time = SystemClock.elapsedRealtime();        try {            service.onStart();//2        } catch (RuntimeException ex) {            throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName()                    + &quot;: onStart threw an exception&quot;, ex);        }        warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;);    }</code></pre><p>startService首先会把当前的service添加到一个名为mServices的list中<br>之后便调用service.onStart()来启动service。<br>以上就是通过SystemServiceManager.startService启动系统服务的过程，总结来说就是通过反射来构造service然后再调用其onStart()来启动。</p><ul><li><strong>第二种启动系统服务的方式是通过调用服务的main方法启动即XXService.main()，以PackageManagerService为例来说明下</strong></li></ul><pre><code>  mPackageManagerService = PackageManagerService.main(mSystemContext, installer,                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</code></pre><p>调用了PackageManagerService的main函数</p><pre><code> public static PackageManagerService main(Context context, Installer installer,            boolean factoryTest, boolean onlyCore) {        // Self-check for initial settings.        PackageManagerServiceCompilerMapping.checkProperties();        PackageManagerService m = new PackageManagerService(context, installer,                factoryTest, onlyCore);//1        m.enableSystemUserPackages();        ServiceManager.addService(&quot;package&quot;, m);//2        final PackageManagerNative pmn = m.new PackageManagerNative();        ServiceManager.addService(&quot;package_native&quot;, pmn);        return m;    }</code></pre><p>在注释1处构造了一个 PackageManagerService实例，然后在注释2处添加到ServiceManager启动。<br><strong>ServiceManager</strong>它是用来管理系统中各种Service的，由它管理的服务都实现了<strong>IBinder</strong>，所以在<strong>ServiceManager</strong>中注册的服务是用于进程间通信的：用于系统<strong>C/S</strong>架构中的<strong>Binder通信机制</strong>。客户端要使用某个<strong>Service</strong>，需要先到<strong>ServiceManager</strong>中查询<strong>Service</strong>的信息，然后根据该信息与<strong>Service</strong>所在的<strong>Server进程</strong>建立通信，这样客户端就可以使用<strong>Service</strong>了。</p><p>至此SystemServer的启动流程完成，我们来简单总结下：<br>1、zygote会通过forkSystemServe来创建SystemServer进程。<br>2、之后通过handleSystemServerProcess来启动SystemServer进程。<br>3、启动过程是通过反射调用SystemServer的main函数。<br>4、SystemServer的main函数会调用run方法，在run方法中初始化了主线程的looper、系统的context等，之后启动了引导、核心、其他等三类系统服务。</p><h4 id="Launcher的启动"><a href="#Launcher的启动" class="headerlink" title="Launcher的启动"></a>Launcher的启动</h4><p>SystemServer的startOtherServices()方法的最后调用了AMS的systemReady<br>这个调用会启动launcher进程。<br>launcher通俗讲就是我们开机看到的桌面，它向我们展示安装完成的app的图标。并且当我们按下对应的图标时启动相应的app。好了 我们看下launcher启动入口。</p><pre><code>    private void startOtherServices() {    ...      mActivityManagerService.systemReady(() -&gt; {//1            Slog.i(TAG, &quot;Making services ready&quot;);            traceBeginAndSlog(&quot;StartActivityManagerReadyPhase&quot;);            mSystemServiceManager.startBootPhase(                    SystemService.PHASE_ACTIVITY_MANAGER_READY);            traceEnd();            traceBeginAndSlog(&quot;StartObservingNativeCrashes&quot;);            try {                mActivityManagerService.startObservingNativeCrashes();            } catch (Throwable e) {                reportWtf(&quot;observing native crashes&quot;, e);            }            traceEnd();           //...        }, BOOT_TIMINGS_TRACE_LOG);    }</code></pre><p>在startOtherServices中注释1处调用ActivityManagerService（AMS）的systemReady方法。</p><pre><code>  public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {  ...          startHomeActivityLocked(currentUserId, &quot;systemReady&quot;);  ...  }</code></pre><p>省略无关内容，我们看在systemReady调用startHomeActivityLocked方法。</p><pre><code> boolean startHomeActivityLocked(int userId, String reason) {        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL                &amp;&amp; mTopAction == null) {            // We are running in factory test mode, but unable to find            // the factory test app, so just sit around displaying the            // error message and don&#39;t try to start anything.            return false;        }        Intent intent = getHomeIntent();//1        ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);        if (aInfo != null) {            intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));            // Don&#39;t do this if the home app is currently being            // instrumented.            aInfo = new ActivityInfo(aInfo);            aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);            ProcessRecord app = getProcessRecordLocked(aInfo.processName,                    aInfo.applicationInfo.uid, true);            if (app == null || app.instr == null) {                intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);                final int resolvedUserId = UserHandle.getUserId(aInfo.applicationInfo.uid);                // For ANR debugging to verify if the user activity is the one that actually                // launched.                final String myReason = reason + &quot;:&quot; + userId + &quot;:&quot; + resolvedUserId;                mActivityStarter.startHomeActivityLocked(intent, aInfo, myReason);//2            }        } else {            Slog.wtf(TAG, &quot;No home screen found for &quot; + intent, new Throwable());        }        return true;    }</code></pre><p>startHomeActivityLocked方法中在注释1处调用<br>getHomeIntent，该方法返回一个intent实例，该实例是启动launcher的intent。该intent的action和Category是匹配launcher的manifest的。</p><pre><code>   Intent getHomeIntent() {        Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);//mTopAction = Intent.ACTION_MAIN        intent.setComponent(mTopComponent);        intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {            intent.addCategory(Intent.CATEGORY_HOME);//该intent的Category是Intent.CATEGORY_HOME        }        return intent;    }</code></pre><p>下面贴下manifest文件</p><pre><code>    &lt;application        android:backupAgent=&quot;com.android.launcher3.LauncherBackupAgent&quot;        android:fullBackupOnly=&quot;true&quot;        android:fullBackupContent=&quot;@xml/backupscheme&quot;        android:hardwareAccelerated=&quot;true&quot;        android:icon=&quot;@drawable/ic_launcher_home&quot;        android:label=&quot;@string/derived_app_name&quot;        android:theme=&quot;@style/LauncherTheme&quot;        android:largeHeap=&quot;@bool/config_largeHeap&quot;        android:restoreAnyVersion=&quot;true&quot;        android:supportsRtl=&quot;true&quot; &gt;        &lt;!--        Main launcher activity. When extending only change the name, and keep all the        attributes and intent filters the same        --&gt;        &lt;activity            android:name=&quot;com.android.launcher3.Launcher&quot;            android:launchMode=&quot;singleTask&quot;            android:clearTaskOnLaunch=&quot;true&quot;            android:stateNotNeeded=&quot;true&quot;            android:windowSoftInputMode=&quot;adjustPan&quot;            android:screenOrientation=&quot;nosensor&quot;            android:configChanges=&quot;keyboard|keyboardHidden|navigation&quot;            android:resizeableActivity=&quot;true&quot;            android:resumeWhilePausing=&quot;true&quot;            android:taskAffinity=&quot;&quot;            android:enabled=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.MONKEY&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER_APP&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;</code></pre><p>看出launcher的action和category是和上面的intent相符合的。</p><p>startHomeActivityLocked方法中的注释2调用了startHomeActivityLocked方法把获得的intent传入来启动launcher。<br>launcher启动完成后我们就在看到了桌面程序，上面显示了安装完成的app的图标。</p><p>我们在此简单总结下launcher的启动流程：<br>1、首先systemserver在启动其他系统服务时会调用AMS的systemReady方法<br>2、systemReady方法中调用startHomeActivityLocked，在这个方法中我们会构造出启动launcher的intent，然后通过startHomeActivityLocked去启动launcher。<br>systemserver启动launcher后会执行launcher的onCreate函数</p><pre><code> protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        LauncherAppState app = LauncherAppState.getInstance(this);//1        // Load configuration-specific DeviceProfile        mDeviceProfile = app.getInvariantDeviceProfile().getDeviceProfile(this);        if (isInMultiWindowModeCompat()) {//2            Display display = getWindowManager().getDefaultDisplay();            Point mwSize = new Point();            display.getSize(mwSize);            mDeviceProfile = mDeviceProfile.getMultiWindowProfile(this, mwSize);        }//3        mOrientation = getResources().getConfiguration().orientation;        mSharedPrefs = Utilities.getPrefs(this);        mIsSafeModeEnabled = getPackageManager().isSafeMode();        mModel = app.setLauncher(this);        mModelWriter = mModel.getWriter(mDeviceProfile.isVerticalBarLayout());        mIconCache = app.getIconCache();        mAccessibilityDelegate = new LauncherAccessibilityDelegate(this);        mDragController = new DragController(this);        mAllAppsController = new AllAppsTransitionController(this);        mStateTransitionAnimation = new LauncherStateTransitionAnimation(this, mAllAppsController);        mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);        mAppWidgetHost = new LauncherAppWidgetHost(this);        if (Utilities.ATLEAST_MARSHMALLOW) {            mAppWidgetHost.addProviderChangeListener(this);        }        mAppWidgetHost.startListening();        // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,        // this also ensures that any synchronous binding below doesn&#39;t re-trigger another        // LauncherModel load.        mPaused = false;        mLauncherView = LayoutInflater.from(this).inflate(R.layout.launcher, null);        setupViews();//4        mDeviceProfile.layout(this, false /* notifyListeners */);        loadExtractedColorsAndColorItems();//5        mPopupDataProvider = new PopupDataProvider(this);        ((AccessibilityManager) getSystemService(ACCESSIBILITY_SERVICE))                .addAccessibilityStateChangeListener(this);        lockAllApps();        restoreState(savedInstanceState);        if (LauncherAppState.PROFILE_STARTUP) {            Trace.endSection();        }        // We only load the page synchronously if the user rotates (or triggers a        // configuration change) while launcher is in the foreground        int currentScreen = PagedView.INVALID_RESTORE_PAGE;        if (savedInstanceState != null) {            currentScreen = savedInstanceState.getInt(RUNTIME_STATE_CURRENT_SCREEN, currentScreen);        }        if (!mModel.startLoader(currentScreen)) {//6            // If we are not binding synchronously, show a fade in animation when            // the first page bind completes.            mDragLayer.setAlpha(0);        } else {            // Pages bound synchronously.            mWorkspace.setCurrentPage(currentScreen);            setWorkspaceLoading(true);        }        // For handling default keys        //7        mDefaultKeySsb = new SpannableStringBuilder();        Selection.setSelection(mDefaultKeySsb, 0);        mRotationEnabled = getResources().getBoolean(R.bool.allow_rotation);        // In case we are on a device with locked rotation, we should look at preferences to check        // if the user has specifically allowed rotation.        if (!mRotationEnabled) {            mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext());            mRotationPrefChangeHandler = new RotationPrefChangeHandler();            mSharedPrefs.registerOnSharedPreferenceChangeListener(mRotationPrefChangeHandler);        }        if (PinItemDragListener.handleDragRequest(this, getIntent())) {            // Temporarily enable the rotation            mRotationEnabled = true;        }        // On large interfaces, or on devices that a user has specifically enabled screen rotation,        // we want the screen to auto-rotate based on the current orientation        setOrientation();        setContentView(mLauncherView);        // Listen for broadcasts        IntentFilter filter = new IntentFilter();        filter.addAction(Intent.ACTION_SCREEN_OFF);        filter.addAction(Intent.ACTION_USER_PRESENT); // When the device wakes up + keyguard is gone        registerReceiver(mReceiver, filter);        mShouldFadeInScrim = true;        getSystemUiController().updateUiState(SystemUiController.UI_STATE_BASE_WINDOW,                Themes.getAttrBoolean(this, R.attr.isWorkspaceDarkText));        if (mLauncherCallbacks != null) {            mLauncherCallbacks.onCreate(savedInstanceState);        }    }</code></pre><p>整个launcher的启动大致分为7步。<br>注释1处执行第一步创建LauncherAppState 对象。不同的手机显示的Launcher布局是一样的，但是其中真正显示的每个图标，<br>每个画面的像素点大小是不同的。Launcher需要根据手机的尺寸密度等参数，计算出更多的信息。第一步是将和手机硬件挂钩的参数都获取出来。</p><p>注释2处执行第二步，分屏模式也叫做多屏模式，在多屏模式的时候，Launcher的布局有很多的变化。此处检查当前是否处于分屏模式，若是则会做相应的处理。</p><p>注释3执行第三步统一创建对象，Launcher启动时需要用到的对象，在这里统一创建，为后面进行布局的显示进行铺垫。</p><p>注释4执行第四步生成桌面分布局，将桌面的各个部分都创建对象，绑定一些事件监听器等，这一步基本将桌面的各个UI子模块都定义完成。</p><p>注释5执行第五步，UI子模块的细节规划，各个模块的大小，真正的尺寸等等。这一步是采用第一步获取的方案，把第四步的模块细节进行完成</p><p>注释6执行第六步，生成布局。Launcher不是一张图片，因为不同的手机之间有区别。前五步完成不同手机的区别， 保证上至平板，下至翻盖机，不同的分辨率下都能够很好的显示。而手机桌面的变化重点是桌面图标布局不一样，手机中安装的软件不一样。第六步就是生成这种布局。</p><p>注释7第七步，横屏和CallBack等善后工作</p><p>至此launcher启动完成我们已经可以在桌面看到安装的app的icon，点击icon就会启动相应的应用。</p><p>其实在launcher内部我们看到的图标排列是通过Android自定义的recycleview实现的，当我们点击icon时会触发onclicklistener监听，而对点击事件的处理则是在launcher的onclick函数中（launcher实现了onclicklistener接口），launcher收到点击事件后会调用startAppShortcutOrInfoActivity启动对应的应用。</p><p>至此Android从启动到桌面显示，然后点击icon启动app的流程已经梳理完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity知识详解</title>
    <link href="/2019/11/30/ActivityDK/"/>
    <url>/2019/11/30/ActivityDK/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Activity知识点详解"><a href="#Activity知识点详解" class="headerlink" title="Activity知识点详解"></a>Activity知识点详解</h1><h2 id="一、什么是Activity"><a href="#一、什么是Activity" class="headerlink" title="一、什么是Activity"></a>一、什么是Activity</h2><p>官方解释：</p><blockquote><p>The Activity class is a crucial component of an Android app, and the way activities are launched and put together is a fundamental part of the platform’s application model. Unlike programming paradigms in which apps are launched with amain()method, the Android system initiates code in an  Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle.<br>Activity是Android应用的重要组成部分，它的启动和组合方式是Android应用程序模型的一个基本部分。与使用 main ()方法启动应用程序的编程范例不同，Android 系统通过调用与其生命周期的特定阶段相对应的特定回调方法来启动 Activity 实例中的代码。<br>我们在日常的开发中接触最多的可能就是Activity了，对于Activity我的理解是它作为Android四大组件之一，主要是给我们提供界面的展示和用户交互。。这里要说下Android的四大组件，Activity、Service、Brocast、ContentProvider功能各不相同但是称它们为四大组件主要是它们四个都是Android应用的入口。我们都知道Java是采用main ()方法启动应用程序的，但是Android并没有采用这种方式，Android设计了四个组件以这些组件为入口来启动一个Android应用。</p></blockquote><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><p>生命周期作为Activity老生常谈的知识点是我们必须要熟练掌握的。这里要分两种情况去理解掌握：正常情况下的生命周期和异常情况下的生命周期。</p><h3 id="正常情况下的生命周期"><a href="#正常情况下的生命周期" class="headerlink" title="正常情况下的生命周期"></a>正常情况下的生命周期</h3><p>这可以说是Activity最基本的知识点了在此就不展开了，贴张图<br><img src="https://developer.android.google.cn/images/components/intent-filters_2x.png" srcset="/img/loading.gif" alt="Activity生命周期"></p><p>再次补充一个关于生命周期的问题就是处于哪些生命周期时是可以被杀死的。<br> onCreate、onStart()、onRestart()、onResume()当Activity处于这些生命周期时是不可被kill的。onPause()在Honeycomb（3.X版本）之前是可以被kill的，而从Honeycomb开始系统在Activity回调onStop()<br>之前是不会杀死Activity的，因为这样可以确保在异常情况下onsaveinstancestate被调用，保存状态。<br>（Android P开始onsaveinstancestate在onStop()之后被调用）</p><h3 id="异常情况下的生命周期"><a href="#异常情况下的生命周期" class="headerlink" title="异常情况下的生命周期"></a>异常情况下的生命周期</h3><p>我们主要注意以下两种情况下的生命周期：</p><h4 id="系统配置发生变化"><a href="#系统配置发生变化" class="headerlink" title="系统配置发生变化"></a>系统配置发生变化</h4><p>比如常见的如屏幕方向发生变化，配置发生变化是会导致Activity销毁重建的，如果我们想保持之前的Activity不被销毁那么我们可以在manifest中设置对应的配置信息 ，之后当其变化时会触发onConfigurationChanged回调此时是不会销毁重建的。但是要注意的是触发回调时当前组件（Activity）必须还在运行 如果组件被暂停 那么是不会触发回调的 。</p><h4 id="内存紧张导致Activity被杀死"><a href="#内存紧张导致Activity被杀死" class="headerlink" title="内存紧张导致Activity被杀死"></a>内存紧张导致Activity被杀死</h4><p>因为Android总体资源有限当内存紧张时系统会根据一定的优先级杀死一些Activity。这里的优先级依次是：前台Activity&gt;可见Activity&gt;后台Activity&gt;空进程。</p><p>除此之外我们还要了解onsaveinstancestate/onrestoreinstancestate回调。<br>onsaveinstancestate是Activity因为异常被系统kill时用来保存当前Activity的有关状态和数据的，我们也可以在该回调中保存我们想要保存的数据以防止Activity因为异常被杀死而丢失数据。之后系统会在合适的时机重建该Activity此时就会触发onrestoreinstancestate回调，在该回调里我们可以拿到之前保存的状态和数据进行恢复（在oncreate中也可以拿到保存的数据不过需要进行判空，所以还是推荐在onrestoreinstancestate进行恢复）。</p><p>最后关于这两个函数的回调时机，系统版本不同会有一些差异：<br>1、 api &lt; 11，onSaveInstance在onPause之前执行<br>2、11 &lt;= api &lt; 28，onSaveInstance在onPause之后，onStop之前执行<br>3、api &gt;= 28，onSaveInstance在onStop之后执行</p><h2 id="三、启动方式"><a href="#三、启动方式" class="headerlink" title="三、启动方式"></a>三、启动方式</h2><h3 id="分类一"><a href="#分类一" class="headerlink" title="分类一"></a>分类一</h3><h4 id="显示启动"><a href="#显示启动" class="headerlink" title="显示启动"></a>显示启动</h4><p>指明ComponentName有明确的启动目标</p><h4 id="隐式启动"><a href="#隐式启动" class="headerlink" title="隐式启动"></a>隐式启动</h4><p>未指明ComponentName，通过匹配intentfilter找到可以启动的目标</p><h3 id="分类二"><a href="#分类二" class="headerlink" title="分类二"></a>分类二</h3><h4 id="不带返回值"><a href="#不带返回值" class="headerlink" title="不带返回值"></a>不带返回值</h4><p>通过startActivity</p><h4 id="带返回值"><a href="#带返回值" class="headerlink" title="带返回值"></a>带返回值</h4><p>startActivityForResult启动并在onActivityResult中接收返回的结果。</p><h2 id="四、任务栈"><a href="#四、任务栈" class="headerlink" title="四、任务栈"></a>四、任务栈</h2><p>Task是用户在执行某项任务时与之交互的Activity的集合。按照每个Activity打开的顺序排列在一个堆栈（先进后出）。一般来说处在栈顶的Activity是正在前台的Activity。<br>总结Activity和Task的默认行为:</p><ul><li>当Activitya 启动Activity b 时，Activity a 停止，但系统保持其状态(如滚动位置和输入到表单中的文本)。 如果用户按下Back键回来那么a 恢复其状态，b被弹出Task并被销毁。</li><li>当用户通过按下Home button当前Activity被停止并且它的任务进入后台。 系统保留任务中每个Activity的状态。 如果用户稍后通过选择启动该Task的启动图标恢复该任务，则该Task将到达前台并恢复堆栈顶部的Activity。</li><li>Activity可以被多次实例化，同时可以从其他Task中实例化</li></ul><p>一般而言我们不需要干预Task的默认行为，但是我们也可以通过以下方法去干预：</p><h3 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h3><p>Affinity表示Activity希望属于哪个Task。 默认情况下，来自同一个应用程序的所有Activity彼此都有相同的Affinity。可以设置Taskaffinity 属性来自定义Affinity。task自身的affinity决定于根Activity的affinity值也就是说同一个task中的所有Activity具有相同的affinity。<br>affinity在什么场合应用呢？<br>1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合工作）；<br>2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task<br>Affinity还有两点要注意：<br>1、根activity的taskAffinity可以决定task的“名字”，activity在启动时和re-parent时需要根据taskAffinity来确定该activity会出现在哪个task<br>2、优先级是activity中指定的taskAffinity&gt;application中指定的taskAffinity&gt;默认的包名</p><h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><p>Android提供了四种启动模式：</p><ul><li><p>standard<br>默认模式 该模式下每次启动activity都会创建新的activity实例。特殊情况，如果在Service或Application中启动一个Activity，其并没有所谓的任务栈，可以使用标记位Flag来解决。解决办法：为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。</p></li><li><p>singleTop<br>启动一个activity如果该activity实例已经已在栈顶则复用并回调onnewintent。应用场景 推送跳转activity</p></li><li><p>singleTask<br>启动一个activity时会先找自己所属的Task，如果该Task已经存在那么查看Task中是否有该activity实例 有则复用并回调onnewintent<br>如果所属的Task还未创建那么就先创建Task然后再创建Activity实例并入栈 所以说singleTask 启动模式的activity 是全局单例的。应用场景 app主页</p></li><li><p>singleInstance<br>可以看做是singleTask的加强版，改启动模式下每次都会启动一个新的Task并将activity实例放到Task 并且Task中只有这一个activity实例。应用场景 呼叫来电。</p><h3 id="activity-attributes或者intent-flags"><a href="#activity-attributes或者intent-flags" class="headerlink" title="activity attributes或者intent flags"></a>activity attributes或者intent flags</h3></li><li><p>android:allowTaskReparenting<br>这个属性用来标记一个Activity实例在当前应用退居后台后，是否能从启动它的那个task移动到有共同affinity的task，“true”表示可以移动，“false”表示它必须呆在当前应用的task中，默认值为false 重新宿主的操作发生在应用退后台再次重启过程中</p></li><li><p>android:alwaysRetainTaskState<br>如果用户长时间离开Task，系统将清除除根Activity以外的所有Activity。 当用户再次返回Task时，只恢复根Activity。但是设置该属性为true后就不会发生清除，即使在很长一段时间之后，任务仍然保留其堆栈中的所有活动。</p></li><li><p>android:clearTaskOnLaunch<br>在Task的根Activity中，只要用户离开Task并返回到该Task，堆栈就会被清除到根Activity。用户总是返回到Task的初始状态，即使离开Task只有一会儿。</p></li><li><p>android: finishOnTaskLaunch<br>它作用于一个单一的Activity，而不是一个完整的Task。 它会导致任何Activity消失，包括根Activity。用户离开，然后返回到Task，则该Task不再存在。</p></li><li><p>FLAG_ACTIVITY_NEW_TASK<br>其效果与指定Activity为singleTask模式一致。系统会寻找或创建一个新的task来放置目标Activity，寻找时依据目标Activity的taskAffinity属性进行匹配，如果找到一个task的taskAffinity与之相同，就将目标Activity压入此task中，如果查找无果，则创建一个新的task，并将该task的taskAffinity设置为目标Activity的taskActivity，将目标Activity放置于此task</p></li><li><p>FLAG_ACTIVITY_SINGLE_TOP<br>其效果与指定Activity为singleTop模式一致。</p></li><li><p>FLAG_ACTIVITY_CLEAR_TOP<br>具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。如果和singleTask模式一起出现，若被启动的Activity已经存在栈中，则清除其之上的Activity，并调用该Activity的onNewIntent方法。如果被启动的Activity采用standard模式，那么该Activity连同之上的所有Activity出栈，然后创建新的Activity实例并压入栈中。如果和FLAG_ACTIVITY_NEW_TASK 一起使用时，则是一种在另一个Task中定位现有Activity并将其放置在能够响应该意图的位置的方法。</p></li><li><p>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET<br>如果一个Intent中包含此属性，则它转向的那个Activity以及在那个Activity其上的所有Activity都会在task重置时被清除出task</p></li></ul><p>最后说明下activity启动时如何选择task：</p><ol><li><p>先判断target activity能否在新task中启动<br>singleTask/singleInstance的activity本身具有在新task中启动的能力，standard/singleTop的activity要想拥有在新task中启动的能力，需要在设置Intent.FLAG_ACTIVITY_NEW_TASK</p></li><li><p>判断target activity所在task<br>找一个taskAffinity的task去启动，找不到就新建一个（这里会忽略了singleInstance独占的task）</p></li><li><p>根据TargetActivity的启动模式判断会如何启动</p></li></ol><h2 id="五、相关问题"><a href="#五、相关问题" class="headerlink" title="五、相关问题"></a>五、相关问题</h2><h3 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged"></a>onWindowFocusChanged</h3><p>在Activity窗口获得或失去焦点时被调用，<br>1、创建时首次呈现在用户面前；<br>2、当前Activity被其他Activity覆盖；<br>3、当前Activity转到其他Activity或按Home键回到主屏，自身退居后台；<br>4、用户退出当前Activity。</p><p>以上几种情况都会调用onWindowFocusChanged，并且当Activity被创建时是在onResume之后被调用，当Activity被覆盖或者退居后台或者当前Activity退出时，它是在onPause之后被调用<br>这个方法在某种场合下还是很有用的，例如程序启动时想要获取视特定视图组件的尺寸大小，在onCreate中可能无法取到，因为窗口Window对象还没创建完成，这个时候我们就需要在onWindowFocusChanged里获取</p><h3 id="其他应用问题："><a href="#其他应用问题：" class="headerlink" title="其他应用问题："></a>其他应用问题：</h3><ol><li>activity间传递数据</li><li>知晓当前activity</li><li>关闭所有activity</li><li>双击退出app</li><li>保存activity状态<h3 id="面试常见知识点"><a href="#面试常见知识点" class="headerlink" title="面试常见知识点"></a>面试常见知识点</h3>Activity A跳转到Activity B 两者经历怎样的生命周期<br>未配置configchanges情况下屏幕发生旋转时 当前Activity的生命周期是怎样变化的</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Okhttp解析之—okhttp缓存机制</title>
    <link href="/2019/11/24/Okhttp4/"/>
    <url>/2019/11/24/Okhttp4/</url>
    
    <content type="html"><![CDATA[<p>Okhttp解析系列</p><a id="more"></a><h1 id="Okhttp源码解析—okhttp缓存机制"><a href="#Okhttp源码解析—okhttp缓存机制" class="headerlink" title="Okhttp源码解析—okhttp缓存机制"></a>Okhttp源码解析—okhttp缓存机制</h1><p>本文主要介绍Http的缓存相关知识并分析okhttp缓存机制是如何实现的。</p><h2 id="Http的缓存相关知识"><a href="#Http的缓存相关知识" class="headerlink" title="Http的缓存相关知识"></a>Http的缓存相关知识</h2><p>缓存对移动端来说是一个很重要的功能，缓存可以提高用户体验，因为缓存可以减少请求服务端的次数而使用本地的“副本”，提高了响应速度。Http作为移动端常用的请求协议它定义了相关的缓存机制，下面一起来看下。</p><h3 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h3><h4 id="分类一"><a href="#分类一" class="headerlink" title="分类一"></a>分类一</h4><ul><li>服务端缓存</li><li>客户端缓存</li></ul><h4 id="分类二"><a href="#分类二" class="headerlink" title="分类二"></a>分类二</h4><ul><li>强制缓存：强制缓存如果命中，则不再和服务器交互了直接返回缓存，只有未命中的情况才会向服务器请求</li><li>对比缓存：对比缓存会先获取缓存数据的标识并向服务端确认缓存是否有效，有效则使用缓存，无效则服务端返回最新的数据客户端收到后更新缓存。<br>两者区别是对比缓存机制无论缓存是否有效都会跟服务端进行通信，而强制缓存只要当前缓存还有效则无需跟服务端通信。</li></ul><h3 id="Http中的缓存设置"><a href="#Http中的缓存设置" class="headerlink" title="Http中的缓存设置"></a>Http中的缓存设置</h3><p>Http定义的缓存规则基本都是在header中设置的。</p><ul><li><p>Expires：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p></li><li><p>Cache-control（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p></li><li><p><em>Cache-Control常见取值以及其含义：*</em><br>```</p></li><li><p>Public指示响应可被任何缓存区缓存。</p></li><li><p>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</p></li><li><p>No-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~</p></li><li><p>No-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</p></li><li><p>Max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</p></li><li><p>Min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</p></li><li><p>Max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p><pre><code></code></pre></li><li><p>Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。</p><pre><code>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP200；若最后修改时间较旧，说明资源无新修改，则响应HTTP304(无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</code></pre></li><li><p>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。</p><pre><code>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。</code></pre></li></ul><p>可以看出Etag和Last-Modified作用类似那为什么要定义两个重复的字段呢？<br>因为Last-Modified有一些难以解决的问题：<br>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间。</p><p>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。</p><p>还有就是有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。<br>以上问题可以通过Etag来解决，Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag一起使用时，服务器会优先验证ETag。</p><h2 id="Okhttp缓存机制"><a href="#Okhttp缓存机制" class="headerlink" title="Okhttp缓存机制"></a>Okhttp缓存机制</h2><p>Okhttp中跟缓存相关的类有CacheControl、CacheStrategy、Cache依次来看下。</p><h3 id="CacheControl"><a href="#CacheControl" class="headerlink" title="CacheControl"></a>CacheControl</h3><p>CacheControl对应的是Http中的Cache-control。</p><pre><code>public final class CacheControl {  /**   * Cache control request directives that require network validation of responses. Note that such   * requests may be assisted by the cache via conditional GET requests.   */  public static final CacheControl FORCE_NETWORK = new Builder().noCache().build();//Okhttp提供的强制使用网络的CacheControl  /**   * Cache control request directives that uses the cache only, even if the cached response is   * stale. If the response isn&#39;t available in the cache or requires server validation, the call   * will fail with a {@code 504 Unsatisfiable Request}.   */  public static final CacheControl FORCE_CACHE = new Builder()      .onlyIfCached()      .maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS)      .build();//Okhttp提供的强制使用Cache的CacheControlprivate final boolean noCache; //对应 HTTP 控制缓存指令的 “no-cache”private final boolean noStore; //对应 HTTP 控制缓存指令的 “no-store”private final int maxAgeSeconds;//对应 HTTP 控制缓存指令的 “max-age”private final int sMaxAgeSeconds;//对应 HTTP 控制缓存指令的 “s-maxage”private final boolean isPrivate;//对应 HTTP 控制缓存指令的 “private”private final boolean isPublic;//对应 HTTP 控制缓存指令的 “public”private final boolean mustRevalidate;//对应 HTTP 控制缓存指令的 “must-revalidate”private final int maxStaleSeconds;//对应 HTTP 控制缓存指令的 “max-stale”private final int minFreshSeconds;//对应 HTTP 控制缓存指令的 “min-fresh”private final boolean onlyIfCached;//对应 HTTP 控制缓存指令的 “only-if-cached”private final boolean noTransform;//对应 HTTP 控制缓存指令的 “no-transform”private final boolean immutable;//对应 HTTP 控制缓存指令的 “immutable”  @Nullable  String headerValue; // Lazily computed, null if absent.  private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,      boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,      @Nullable String headerValue) {    this.noCache = noCache;    this.noStore = noStore;    this.maxAgeSeconds = maxAgeSeconds;    this.sMaxAgeSeconds = sMaxAgeSeconds;    this.isPrivate = isPrivate;    this.isPublic = isPublic;    this.mustRevalidate = mustRevalidate;    this.maxStaleSeconds = maxStaleSeconds;    this.minFreshSeconds = minFreshSeconds;    this.onlyIfCached = onlyIfCached;    this.noTransform = noTransform;    this.immutable = immutable;    this.headerValue = headerValue;  }}</code></pre><p>CacheControl提供了Bulider模式来构造CacheControl实例。同时我们可以看到CacheControl很多字段跟Http的缓存字段一一对应。<br>在此解释几个含义：<br>noCache：如果出现在respone的头部，不是表示不允许对响应进行缓存，而是表示客户端需要与服务器进行再次验证，进行一个额外的GET请求得到最新的响应；如果出现request头部，则表示不使用缓存响应，即需要网络请求获取响应。<br>noStore：设置为true 则respone不会被缓存<br>maxAgeSeconds：缓存响应的最大存活时间。如果缓存未到最大存活时间，那么将不会再进行网络请求<br>sMaxAgeSeconds：共享缓存最大存活时间，需要注意跟<em>max-age</em>表示含义并不相同<br>onlyIfCached：强制使用缓存不经过网络请求（包括向服务器验证）</p><p>同时CacheControl还提供的parse方法，传入一个Header，该函数会解析header中的相关字段然后封装成为一个CacheControl并返回。</p><pre><code>public static CacheControl parse(Headers headers) {       //...省略       //解析相关header字段      if (&quot;no-cache&quot;.equalsIgnoreCase(directive)) {        noCache = true;      } else if (&quot;no-store&quot;.equalsIgnoreCase(directive)) {        noStore = true;      } else if (&quot;max-age&quot;.equalsIgnoreCase(directive)) {        maxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);      } else if (&quot;s-maxage&quot;.equalsIgnoreCase(directive)) {        sMaxAgeSeconds = HttpHeaders.parseSeconds(parameter, -1);      } else if (&quot;private&quot;.equalsIgnoreCase(directive)) {        isPrivate = true;      } else if (&quot;public&quot;.equalsIgnoreCase(directive)) {        isPublic = true;      } else if (&quot;must-revalidate&quot;.equalsIgnoreCase(directive)) {        mustRevalidate = true;      } else if (&quot;max-stale&quot;.equalsIgnoreCase(directive)) {        maxStaleSeconds = HttpHeaders.parseSeconds(parameter, Integer.MAX_VALUE);      } else if (&quot;min-fresh&quot;.equalsIgnoreCase(directive)) {        minFreshSeconds = HttpHeaders.parseSeconds(parameter, -1);      } else if (&quot;only-if-cached&quot;.equalsIgnoreCase(directive)) {        onlyIfCached = true;      } else if (&quot;no-transform&quot;.equalsIgnoreCase(directive)) {        noTransform = true;      } else if (&quot;immutable&quot;.equalsIgnoreCase(directive)) {        immutable = true;      }    }  }  if (!canUseHeaderValue) {    headerValue = null;  }  return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,      mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,      headerValue);//将解析好的Header封装为一个 CacheControl并返回}</code></pre><h3 id="CacheStrategy"><a href="#CacheStrategy" class="headerlink" title="CacheStrategy"></a>CacheStrategy</h3><p> CacheStrategy是Okhttp提供的一个缓存策略类，它决定了是使用网络还是缓存或者两者都用。</p><pre><code>public final class CacheStrategy {  /** The request to send on the network, or null if this call doesn&#39;t use the network. */  public final @Nullable  Request networkRequest;  /** The cached response to return or validate; or null if this call doesn&#39;t use a cache. */  public final @Nullable Response cacheResponse;  CacheStrategy(Request networkRequest, Response cacheResponse) {    this.networkRequest = networkRequest;    this.cacheResponse = cacheResponse;  }  /** Returns true if {@code response} can be stored to later serve another request. */  public static boolean isCacheable(Response response, Request request) {    // Always go to network for uncacheable response codes (RFC 7231 section 6.1),    // This implementation doesn&#39;t support caching partial content.    switch (response.code()) {//根据respone中的返回状态码来确定该respone是否可以被缓存      case HTTP_OK:      case HTTP_NOT_AUTHORITATIVE:      case HTTP_NO_CONTENT:      case HTTP_MULT_CHOICE:      case HTTP_MOVED_PERM:      case HTTP_NOT_FOUND:      case HTTP_BAD_METHOD:      case HTTP_GONE:      case HTTP_REQ_TOO_LONG:      case HTTP_NOT_IMPLEMENTED:      case StatusLine.HTTP_PERM_REDIRECT:        // These codes can be cached unless headers forbid it.        break;      case HTTP_MOVED_TEMP:      case StatusLine.HTTP_TEMP_REDIRECT:        // These codes can only be cached with the right response headers.        // http://tools.ietf.org/html/rfc7234#section-3        // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.        if (response.header(&quot;Expires&quot;) != null            || response.cacheControl().maxAgeSeconds() != -1            || response.cacheControl().isPublic()            || response.cacheControl().isPrivate()) {          break;        }        // Fall-through.      default:        // All other codes cannot be cached.        return false;    }    // A &#39;no-store&#39; directive on request or response prevents the response from being cached.    return !response.cacheControl().noStore() &amp;&amp; !request.cacheControl().noStore();  }}</code></pre><p>可以看出它的实现很简单，有一个networkRequest用来进行网络请求（使用缓存则为null）一个cacheResponse表示缓存响应（如果使用网络则为null），并提供了一个isCacheable来判断传入的respone是否可以被缓存。</p><p>除此之外CacheStrategy还有一个内部工厂类Factory用来对外提供CacheStrategy实例。</p><pre><code> public static class Factory {    final long nowMillis;    final Request request;    final Response cacheResponse;    /** The server&#39;s time when the cached response was served, if known. */    private Date servedDate;    private String servedDateString;    /** The last modified date of the cached response, if known. */    private Date lastModified;    private String lastModifiedString;    /**     * The expiration date of the cached response, if known. If both this field and the max age are     * set, the max age is preferred.     */    private Date expires;    /**     * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was     * first initiated.     */    private long sentRequestMillis;    /**     * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was     * first received.     */    private long receivedResponseMillis;    /** Etag of the cached response. */    private String etag;    /** Age of the cached response. */    private int ageSeconds = -1;    public Factory(long nowMillis, Request request, Response cacheResponse) {      this.nowMillis = nowMillis;      this.request = request;      this.cacheResponse = cacheResponse;      if (cacheResponse != null) {        this.sentRequestMillis = cacheResponse.sentRequestAtMillis();        this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();        Headers headers = cacheResponse.headers();        for (int i = 0, size = headers.size(); i &lt; size; i++) {          String fieldName = headers.name(i);          String value = headers.value(i);          if (&quot;Date&quot;.equalsIgnoreCase(fieldName)) {            servedDate = HttpDate.parse(value);            servedDateString = value;          } else if (&quot;Expires&quot;.equalsIgnoreCase(fieldName)) {            expires = HttpDate.parse(value);          } else if (&quot;Last-Modified&quot;.equalsIgnoreCase(fieldName)) {            lastModified = HttpDate.parse(value);            lastModifiedString = value;          } else if (&quot;ETag&quot;.equalsIgnoreCase(fieldName)) {            etag = value;          } else if (&quot;Age&quot;.equalsIgnoreCase(fieldName)) {            ageSeconds = HttpHeaders.parseSeconds(value, -1);          }        }      }    }  }</code></pre><p>外部获取CacheStrategy实例方式一般如下：</p><pre><code>CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</code></pre><p>可以看出是构造了一个Factory然后通过其get()函数获取CacheStrategy实例的。在Factory的构造函数中会解析传入的缓存respone（仅非null情况）的header获取相关字段的值如Expires、Last-Modified、ETag等等。接下来看下get函数。</p><pre><code>   /**     * Returns a strategy to satisfy {@code request} using the a cached response {@code response}.     */    public CacheStrategy get() {      CacheStrategy candidate = getCandidate();      if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) {        // We&#39;re forbidden from using the network and the cache is insufficient.        return new CacheStrategy(null, null);      }      return candidate;    }</code></pre><p>Get函数调用getCandidate获取了一个CacheStrategy，然后如果当前禁止使用网络且缓存不可用则会返回一个networkRequest、cacheResponse均为null的CacheStrategy否则返回getCandidate获取的getCandidate获取。</p><p>来看下getCandidate是如何获取CacheStrategy的</p><pre><code>    /** Returns a strategy to use assuming the request can use the network. */    private CacheStrategy getCandidate() {      // No cached response.没有缓存则返回一个cacheresponse为null的CacheStrategy      if (cacheResponse == null) {        return new CacheStrategy(request, null);      }      // Drop the cached response if it&#39;s missing a required handshake.请求是https且缺少必要的握手返回一个cacheresponse为null的CacheStrategy      if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) {        return new CacheStrategy(request, null);      }      // If this response shouldn&#39;t have been stored, it should never be used      // as a response source. This check should be redundant as long as the      // persistence store is well-behaved and the rules are constant.不能被缓存返回一个cacheresponse为null的CacheStrategy      if (!isCacheable(cacheResponse, request)) {        return new CacheStrategy(request, null);      }      CacheControl requestCaching = request.cacheControl();      if (requestCaching.noCache() || hasConditions(request)) {//请求中CacheControl设置不用缓存返回一个cacheresponse为null的CacheStrategy        return new CacheStrategy(request, null);      }      CacheControl responseCaching = cacheResponse.cacheControl();      long ageMillis = cacheResponseAge();      long freshMillis = computeFreshnessLifetime();      if (requestCaching.maxAgeSeconds() != -1) {        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));      }      long minFreshMillis = 0;      if (requestCaching.minFreshSeconds() != -1) {        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());      }      long maxStaleMillis = 0;      if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) {        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());      }            //如果响应缓存中没有配置 “no-cache”,并且 持续时间+最短刷新时间 &lt; 上次刷新时间+最大验证时间 如果都满足条件的话则可以缓存      if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) {        Response.Builder builder = cacheResponse.newBuilder();        if (ageMillis + minFreshMillis &gt;= freshMillis) {          builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;);        }        long oneDayMillis = 24 * 60 * 60 * 1000L;        if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) {          builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;);        }        return new CacheStrategy(null, builder.build());      }      // Find a condition to add to the request. If the condition is satisfied, the response body      // will not be transmitted.      String conditionName;      String conditionValue;      if (etag != null) {        conditionName = &quot;If-None-Match&quot;;        conditionValue = etag;      } else if (lastModified != null) {        conditionName = &quot;If-Modified-Since&quot;;        conditionValue = lastModifiedString;      } else if (servedDate != null) {        conditionName = &quot;If-Modified-Since&quot;;        conditionValue = servedDateString;      } else {        return new CacheStrategy(request, null); // No condition! Make a regular request.      }      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);      Request conditionalRequest = request.newBuilder()          .headers(conditionalRequestHeaders.build())          .build();      return new CacheStrategy(conditionalRequest, cacheResponse);    }</code></pre><p>可以看出getCandidate主要作用就是根据不同的情况返回对应的CacheStrategy。</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>Cache作用是将HTTP和HTTPS响应缓存到文件系统，以便它们可以重复使用，从而节省时间和带宽。</p><pre><code>public final class Cache implements Closeable, Flushable {  final DiskLruCache cache;、//内部持有一个DiskLruCache  /* read and write statistics, all guarded by &#39;this&#39; */  int writeSuccessCount;  int writeAbortCount;  private int networkCount;  private int hitCount;  private int requestCount;  /**   * Create a cache of at most {@code maxSize} bytes in {@code directory}.   */  public Cache(File directory, long maxSize) {    this(directory, maxSize, FileSystem.SYSTEM);  }  Cache(File directory, long maxSize, FileSystem fileSystem) {    this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);  }}</code></pre><p>通过Cache的构造函数我们看到构造Cache需要指定缓存目录以及缓存文件的最大存储量。并且Cache实际的存储是通过DiskLruCache完成的。<br>那么我们来看下Cache的增删改查操作。</p><h4 id="增———put操作"><a href="#增———put操作" class="headerlink" title="增———put操作"></a>增———put操作</h4><pre><code>@Nullable CacheRequest put(Response response) {  String requestMethod = response.request().method();//如果是&quot;POST&quot;、&quot;PATCH&quot;、&quot;PUT&quot;、&quot;DELETE&quot;、&quot;MOVE&quot;中的任何一个则通过remove将这个请求从缓存中移除出去  if (HttpMethod.invalidatesCache(response.request().method())) {    try {      remove(response.request());    } catch (IOException ignored) {      // The cache cannot be written.    }    return null;  }   //如果请求不是Get则不进行缓存，直接返回null。官方给的解释是缓存get方法得到的Response效率高，其它方法的Response没有缓存效率低。通常通过get方法获取到的数据都是固定不变的的，因此缓存效率自然就高了。其它方法会根据请求报文参数的不同得到不同的Response，因此缓存效率自然而然就低了。  if (!requestMethod.equals(&quot;GET&quot;)) {    // Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache    // HEAD requests and some POST requests, but the complexity of doing    // so is high and the benefit is low.    return null;  }//判断请求中的http数据包中headers是否有符号&quot;*&quot;的通配符，有则不缓存直接返回null  if (HttpHeaders.hasVaryAll(response)) {    return null;  }  Entry entry = new Entry(response);  DiskLruCache.Editor editor = null;  try {//通过调用DiskLruCache.edit()方法得到一个DiskLruCache.Editor对象    editor = cache.edit(key(response.request().url()));    if (editor == null) {      return null;    }//把这个entry写入//方法内部是通过Okio.buffer(editor.newSink(ENTRY_METADATA));获取到一个BufferedSink对象，随后将Entry中存储的Http报头数据写入到sink流中。    entry.writeTo(editor);//构建一个CacheRequestImpl对象，构造器中通过editor.newSink(ENTRY_BODY)方法获得Sink对象    return new CacheRequestImpl(editor);  } catch (IOException e) {    abortQuietly(editor);    return null;  }}</code></pre><p>CacheRequestImpl构造函数</p><pre><code>CacheRequestImpl(final DiskLruCache.Editor editor) {  this.editor = editor;  this.cacheOut = editor.newSink(ENTRY_BODY);  this.body = new ForwardingSink(cacheOut) {    @Override public void close() throws IOException {      synchronized (Cache.this) {        if (done) {          return;        }        done = true;        writeSuccessCount++;      }      super.close();      editor.commit();    }  };}</code></pre><h4 id="删———remove"><a href="#删———remove" class="headerlink" title="删———remove"></a>删———remove</h4><pre><code>void remove(Request request) throws IOException {  cache.remove(key(request.url()));}public static String key(HttpUrl url) {  return ByteString.encodeUtf8(url.toString()).md5().hex();}</code></pre><p>remove就是调用DiskLruCache的remove操作进行移除，注意此处是根据key来进行移除的，keyurl是url的MD5和hex生成的。</p><h4 id="改———update"><a href="#改———update" class="headerlink" title="改———update"></a>改———update</h4><pre><code>void update(Response cached, Response network) {  Entry entry = new Entry(network);  DiskLruCache.Snapshot snapshot = ((CacheResponseBody) cached.body()).snapshot;//从DiskLruCache.Snapshot获取DiskLruCache.Editor()对象  DiskLruCache.Editor editor = null;  try {    editor = snapshot.edit(); // Returns null if snapshot is not current.    if (editor != null) {        //将entry写入editor中      entry.writeTo(editor);      editor.commit();    }  } catch (IOException e) {    abortQuietly(editor);  }}</code></pre><h4 id="查———get"><a href="#查———get" class="headerlink" title="查———get"></a>查———get</h4><pre><code>@Nullable Response get(Request request) {  String key = key(request.url());//获取key  DiskLruCache.Snapshot snapshot;  Entry entry;  try {//通过DiskLruCache.get获取一个snapshot    snapshot = cache.get(key);    if (snapshot == null) {      return null;    }  } catch (IOException e) {    // Give up because the cache cannot be read.    return null;  }  try {    //利用前面的Snapshot创建一个Entry对象。存储的内容是响应的Http数据包Header部分的数据。snapshot.getSource得到的是一个Source对象 (source是okio里面的一个接口)    entry = new Entry(snapshot.getSource(ENTRY_METADATA));  } catch (IOException e) {    Util.closeQuietly(snapshot);    return null;  }    //利用entry和snapshot得到Response对象，该方法内部会利用前面的Entry和Snapshot得到响应的Http数据包Body（body的获取方式通过snapshot.getSource(ENTRY_BODY)得到）创建一个CacheResponseBody对象；再利用该CacheResponseBody对象和第三步得到的Entry对象构建一个Response的对象，这样该对象就包含了一个网络响应的全部数据了。  Response response = entry.response(snapshot);    //对request和Response进行比配检查，成功则返回该Response。匹配方法就是url.equals(request.url().toString()) &amp;&amp; requestMethod.equals(request.method()) &amp;&amp; OkHeaders.varyMatches(response, varyHeaders, request);其中Entry.url和Entry.requestMethod两个值在构建的时候就被初始化好了，初始化值从命中的缓存中获取。因此该匹配方法就是将缓存的请求url和请求方法跟新的客户请求进行对比。最后OkHeaders.varyMatches(response, varyHeaders, request)是检查命中的缓存Http报头跟新的客户请求的Http报头中的键值对是否一样。如果全部结果为真，则返回命中的Response。  if (!entry.matches(request, response)) {    Util.closeQuietly(response.body());    return null;  }  return response;}</code></pre><p>可以看出Cache的操作都是通过DiskLruCache来完成的，DiskLruCache的实现在此就不展开分析了。</p><p>以上就是Http的缓存知识以及Okhttp缓存机制的源码分析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Okhttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Okhttp解析之--Interceptor详解</title>
    <link href="/2019/11/17/Okhttp3/"/>
    <url>/2019/11/17/Okhttp3/</url>
    
    <content type="html"><![CDATA[<p>Okhttp解析系列</p><a id="more"></a><h1 id="Okhttp解析—Interceptor详解"><a href="#Okhttp解析—Interceptor详解" class="headerlink" title="Okhttp解析—Interceptor详解"></a>Okhttp解析—Interceptor详解</h1><p>Interceptor可以说是okhttp的精髓之一，Okhttp重写请求/响应、重试、缓存响应等操作，基本都是在各个Interceptor中完成的，上篇文章分析Okhttp运行流程时只是简单带过，那么这篇文章就来详细分析下Interceptor以及拦截器链机制。</p><h2 id="一、Interceptor以及InterceptorChain"><a href="#一、Interceptor以及InterceptorChain" class="headerlink" title="一、Interceptor以及InterceptorChain"></a>一、Interceptor以及InterceptorChain</h2><pre><code>/** * Observes, modifies, and potentially short-circuits requests going out and the corresponding * responses coming back in. Typically interceptors add, remove, or transform headers on the request * or response. */public interface Interceptor {  Response intercept(Chain chain) throws IOException;  interface Chain {    Request request();    Response proceed(Request request) throws IOException;    /**     * Returns the connection the request will be executed on. This is only available in the chains     * of network interceptors; for application interceptors this is always null.     */    @Nullable Connection connection();    Call call();    int connectTimeoutMillis();    Chain withConnectTimeout(int timeout, TimeUnit unit);    int readTimeoutMillis();    Chain withReadTimeout(int timeout, TimeUnit unit);    int writeTimeoutMillis();    Chain withWriteTimeout(int timeout, TimeUnit unit);  }}</code></pre><p>Interceptor最主要的就是其intercept（）函数，InterceptorChain则是Interceptor一个内部类，它的主要作用就是链式有序调用Interceptor。</p><p>Okhttp内置了5种Interceptor它们分别是RetryAndFollowUpInterceptor<br>、BridgeInterceptor、CacheInterceptor、ConnectInterceptor<br>、CallServerInterceptor。正是这5种Interceptor完成了重写、重试、缓存、请求等操作，接下来我们来逐一分析它们的作用。</p><h2 id="二、Interceptor链式调用"><a href="#二、Interceptor链式调用" class="headerlink" title="二、Interceptor链式调用"></a>二、Interceptor链式调用</h2><p>拦截器调用的入口是在ReallCall的getResponseWithInterceptorChain()函数中。</p><pre><code>Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    interceptors.addAll(client.interceptors());    interceptors.add(new RetryAndFollowUpInterceptor(client));    interceptors.add(new BridgeInterceptor(client.cookieJar()));    interceptors.add(new CacheInterceptor(client.internalCache()));    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,        originalRequest, this, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());//1    boolean calledNoMoreExchanges = false;    try {      Response response = chain.proceed(originalRequest);//2      if (transmitter.isCanceled()) {        closeQuietly(response);        throw new IOException(&quot;Canceled&quot;);      }      return response;    } catch (IOException e) {      calledNoMoreExchanges = true;      throw transmitter.noMoreExchanges(e);    } finally {      if (!calledNoMoreExchanges) {        transmitter.noMoreExchanges(null);      }    }  }</code></pre><p>我们看到该函数一开始就构造了一个List然后向里边添加所有的Interceptor，包括我们自定义的Application Interceptor、系统预置的Interceptor、自定义的Network Interceptor等。<br>然后在注释1处构造RealInterceptorChain实例并传入刚刚的interceptor list还有就是我们看到第四个参数此处传入的是0。该参数表示接下来要调用interceptor list中哪个interceptor。<br>最后在注释2处调用chain.proceed（）并传入原始请求。</p><pre><code>@Override public Response proceed(Request request) throws IOException {  return proceed(request, transmitter, exchange);}public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)    throws IOException {  if (index &gt;= interceptors.size()) throw new AssertionError();  calls++;  // If we already have a stream, confirm that the incoming request will use it.  if (this.exchange != null &amp;&amp; !this.exchange.connection().supportsUrl(request.url())) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must retain the same host and port&quot;);  }  // If we already have a stream, confirm that this is the only call to chain.proceed().  if (this.exchange != null &amp;&amp; calls &gt; 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)        + &quot; must call proceed() exactly once&quot;);  }  // Call the next interceptor in the chain.  RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,      index + 1, request, call, connectTimeout, readTimeout, writeTimeout);//1  Interceptor interceptor = interceptors.get(index);//2  Response response = interceptor.intercept(next);//3  // Confirm that the next interceptor made its required call to chain.proceed().  if (exchange != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {    throw new IllegalStateException(&quot;network interceptor &quot; + interceptor        + &quot; must call proceed() exactly once&quot;);  }  // Confirm that the intercepted response isn&#39;t null.  if (response == null) {    throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);  }  if (response.body() == null) {    throw new IllegalStateException(        &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);  }  return response;}</code></pre><p>proceed函数我们主要关注3个注释处的操作。<br>在注释1处构造RealInterceptorChain，其中参数4此时变为index+1，index就是之前在getResponseWithInterceptorChain中构造RealInterceptorChain时传入的值。</p><p>注释2处通过index从Interceptor list中取出对应的Interceptor。<br>注释3处调用Interceptor的intercept（）方法，参数传入注释1处构造的RealInterceptorChain。因为Interceptor的操作都是在intercept（）函数中完成的，所以该操作完成了当前Interceptor的调用。同时在每个Interceptor的intercept（）函数中都会调用next.proceed（）这样就开启了下一个Interceptor调用，如此反复最终像链条一样依次调用Interceptor list中所有的Interceptor。</p><h2 id="三、详解各个Interceptor"><a href="#三、详解各个Interceptor" class="headerlink" title="三、详解各个Interceptor"></a>三、详解各个Interceptor</h2><p>上边我们分析了Interceptor是按顺序调用的，这里的顺序指的是添加到Interceptor list中的先后。由getResponseWithInterceptorChain()方法可以调用的顺序依次是（未考虑添加自定义Interceptor的情况）：RetryAndFollowUpInterceptor–&gt;BridgeInterceptor–&gt;CacheInterceptor–&gt;ConnectInterceptor–&gt;CallServerInterceptor。</p><h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>RetryAndFollowUpInterceptor的作用主要是重试与重定向。<br>来看下它的Interceptor方法。</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {  Request request = chain.request();//获取传入的chain的request 此处的request是next的request  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Transmitter transmitter = realChain.transmitter();  int followUpCount = 0;  Response priorResponse = null;  while (true) {//开启一个无限循环    transmitter.prepareToConnect(request);    if (transmitter.isCanceled()) {//如果此时请求被cancel抛出异常      throw new IOException(&quot;Canceled&quot;);    }    Response response;    boolean success = false;    try {      response = realChain.proceed(request, transmitter, null);//调用next的proceed方法，即调用下一个Interceptor      success = true;    } catch (RouteException e) {//如果通过某个route连接失败则尝试恢复。注意此时请求尚未发送出去      // The attempt to connect via a route failed. The request will not have been sent.      if (!recover(e.getLastConnectException(), transmitter, false, request)) {        throw e.getFirstConnectException();      }      continue;    } catch (IOException e) {//如果连接server失败则尝试恢复，注意此时请求已发送。      // An attempt to communicate with a server failed. The request may have been sent.      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);      if (!recover(e, transmitter, requestSendStarted, request)) throw e;      continue;    } finally {      // The network call threw an exception. Release any resources.      if (!success) {//执行不成功关闭        transmitter.exchangeDoneDueToException();      }    }    // Attach the prior response if it exists. Such responses never have a body.    if (priorResponse != null) {//priorResponse不为空表示之前发生过重定向，此时为本次的response设置priorResponse      response = response.newBuilder()          .priorResponse(priorResponse.newBuilder()                  .body(null)                  .build())          .build();    }    Exchange exchange = Internal.instance.exchange(response);    Route route = exchange != null ? exchange.connection().route() : null;    Request followUp = followUpRequest(response, route);//生成重定向的请求    if (followUp == null) {//followUp == null说明无需重定向，返回当前respone      if (exchange != null &amp;&amp; exchange.isDuplex()) {        transmitter.timeoutEarlyExit();      }      return response;    }    RequestBody followUpBody = followUp.body();    if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {      return response;    }    closeQuietly(response.body());    if (transmitter.hasExchange()) {      exchange.detachWithViolence();    }    if (++followUpCount &gt; MAX_FOLLOW_UPS) {//判断是否超过最大重定向次数      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);    }    request = followUp;    priorResponse = response;  }}</code></pre><p>来，梳理下整个流程：</p><ol><li>开启一个无限循环，直至没有重定向或有异常抛出才会结束。</li><li>处理cancel</li><li>调用下一个Interceptor获取respone</li><li>如果步骤3发生异常，尝试恢复并重试请求</li><li>如果步骤3未发生异常为，priorResponse不为空（如果priorResponse表示之前发生过重定向），为当前respone设置priorResponse（注意priorResponse body是null）</li><li>调用followUpRequest根据返回的code生成用于重定向的请求</li><li>步骤6生成的请求为空表示无需重定向，返回当前respone，结束循环</li><li>步骤6生成的请求不为空表示需要重定向，此时重定向次数+1，然后判断是否超过最大重定向次数，未超过则跳转到步骤2开始下次循环。</li></ol><p>步骤3是拦截器能链式有序调用的关键。<br>步骤4的判断是否能恢复是通过recover（）函数，具体看注释</p><pre><code>/** * Report and attempt to recover from a failure to communicate with a server. Returns true if * {@code e} is recoverable, or false if the failure is permanent. Requests with a body can only * be recovered if the body is buffered or if the failure occurred before the request has been * sent. */private boolean recover(IOException e, Transmitter transmitter,    boolean requestSendStarted, Request userRequest) {  // The application layer has forbidden retries.//应用设置禁止重试 返回false  if (!client.retryOnConnectionFailure()) return false;  // We can&#39;t send the request body again.//request设置仅能执行一次 返回false  if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false;  // This exception is fatal.//异常是致命的 返回false  if (!isRecoverable(e, requestSendStarted)) return false;  // No more routes to attempt.//没有更多的route可供尝试 返回fasle  if (!transmitter.canRetry()) return false;  // For failure recovery, use the same route selector with a new connection.  return true;}</code></pre><p>可以看出恢复操作是有条件的，在某些条件下是不能恢复的。另外上面说的不可恢复致命异常有ProtocolException、InterruptedIOException、SSLHandshakeException、CertificateException<br>、SSLPeerUnverifiedException。</p><p>步骤6的followUpRequest可以说是重定向的核心了，看下followUpRequest函数</p><pre><code>private Request followUpRequest(Response userResponse, @Nullable Route route) throws IOException {  if (userResponse == null) throw new IllegalStateException();  int responseCode = userResponse.code();//获取当前respone的返回code  final String method = userResponse.request().method();  switch (responseCode) {//根据responseCode的值分情况处理    case HTTP_PROXY_AUTH://407      Proxy selectedProxy = route != null          ? route.proxy()          : client.proxy();      if (selectedProxy.type() != Proxy.Type.HTTP) {        throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;);      }      return client.proxyAuthenticator().authenticate(route, userResponse);//代理验证    case HTTP_UNAUTHORIZED://401      return client.authenticator().authenticate(route, userResponse);//身份认证    case HTTP_PERM_REDIRECT:    case HTTP_TEMP_REDIRECT:      // &quot;If the 307 or 308 status code is received in response to a request other than GET      // or HEAD, the user agent MUST NOT automatically redirect the request&quot;      if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) {//307、308 两种code不对 GET、HEAD 以外的请求重定向        return null;      }      // fall-through    case HTTP_MULT_CHOICE://300    case HTTP_MOVED_PERM://301    case HTTP_MOVED_TEMP://302    case HTTP_SEE_OTHER://303 //以上这四种code是可以进行重定向的      // Does the client allow redirects?      if (!client.followRedirects()) return null;//客户端不允许重定向 返回null      String location = userResponse.header(&quot;Location&quot;);//获取Location以确定重定向目标      if (location == null) return null;//Response的Location为null 返回null      HttpUrl url = userResponse.request().url().resolve(location);      // Don&#39;t follow redirects to unsupported protocols.      if (url == null) return null;      // If configured, don&#39;t follow redirects between SSL and non-SSL.      boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());      if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null;      // Most redirects don&#39;t include a request body.      Request.Builder requestBuilder = userResponse.request().newBuilder();      if (HttpMethod.permitsRequestBody(method)) {        final boolean maintainBody = HttpMethod.redirectsWithBody(method);//是否带body重定向        if (HttpMethod.redirectsToGet(method)) {          requestBuilder.method(&quot;GET&quot;, null);        } else {          RequestBody requestBody = maintainBody ? userResponse.request().body() : null;          requestBuilder.method(method, requestBody);        }        if (!maintainBody) {          requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);          requestBuilder.removeHeader(&quot;Content-Length&quot;);          requestBuilder.removeHeader(&quot;Content-Type&quot;);        }      }      // When redirecting across hosts, drop all authentication headers. This      // is potentially annoying to the application layer since they have no      // way to retain them.      if (!sameConnection(userResponse.request().url(), url)) {        requestBuilder.removeHeader(&quot;Authorization&quot;);      }      return requestBuilder.url(url).build();//返回构造的重定向request    case HTTP_CLIENT_TIMEOUT://408 实际很少用到，一般需要重复发送一个相同的请求      // 408&#39;s are rare in practice, but some servers like HAProxy use this response code. The      // spec says that we may repeat the request without modifications. Modern browsers also      // repeat the request (even non-idempotent ones.)      if (!client.retryOnConnectionFailure()) {        // The application layer has directed us not to retry the request.        return null;      }      RequestBody requestBody = userResponse.request().body();      if (requestBody != null &amp;&amp; requestBody.isOneShot()) {        return null;      }      if (userResponse.priorResponse() != null          &amp;&amp; userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {        // We attempted to retry and got another timeout. Give up.        return null;      }      if (retryAfter(userResponse, 0) &gt; 0) {        return null;      }      return userResponse.request();    case HTTP_UNAVAILABLE://503      if (userResponse.priorResponse() != null          &amp;&amp; userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {        // We attempted to retry and got another timeout. Give up.        return null;      }      if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {        // specifically received an instruction to retry without delay        return userResponse.request();      }      return null;    default:      return null;  }}</code></pre><p>followUpRequest主要是根据返回的code分情况处理，如果允许重定向则返回新构造的request否则返回null表示不允许重定向。</p><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>BridgeInterceptor名为桥接拦截器主要作用就是把我们传入的request“重写”为实际向server请求的request，收到respone后“重写”respone。来看下其intercept函数</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {  Request userRequest = chain.request();  Request.Builder requestBuilder = userRequest.newBuilder();  RequestBody body = userRequest.body();//获取请求body  if (body != null) {//请求发送前“重写”headers    MediaType contentType = body.contentType();    if (contentType != null) {      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());    }    long contentLength = body.contentLength();    if (contentLength != -1) {      requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);    } else {      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);      requestBuilder.removeHeader(&quot;Content-Length&quot;);    }  }  if (userRequest.header(&quot;Host&quot;) == null) {    requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));  }  if (userRequest.header(&quot;Connection&quot;) == null) {    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);  }  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing  // the transfer stream.  boolean transparentGzip = false;  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) {    transparentGzip = true;    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);  }  List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());  if (!cookies.isEmpty()) {//cookie不为空则添加cookie    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));  }  if (userRequest.header(&quot;User-Agent&quot;) == null) {//设置User-Agent    requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());  }  Response networkResponse = chain.proceed(requestBuilder.build());//开启下一个拦截器的调用  HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());//从这里开始是收到respone然后对其“重写”  Response.Builder responseBuilder = networkResponse.newBuilder()      .request(userRequest);  if (transparentGzip      &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))      &amp;&amp; HttpHeaders.hasBody(networkResponse)) {//如果之前采用gzip进行压缩，那么需要对respone进行解压    GzipSource responseBody = new GzipSource(networkResponse.body().source());    Headers strippedHeaders = networkResponse.headers().newBuilder()        .removeAll(&quot;Content-Encoding&quot;)        .removeAll(&quot;Content-Length&quot;)        .build();    responseBuilder.headers(strippedHeaders);    String contentType = networkResponse.header(&quot;Content-Type&quot;);    responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));  }  return responseBuilder.build();}</code></pre><p>BridgeInterceptor完成的工作可以分为3步：</p><ol><li>请求发送前对request“重写”，重写后的request才是实际去用来请求的request。</li><li>调用chain.proceed开启下一个拦截器调用，并拿到respone</li><li>对返回的respone进行“重写”，我们拿到的respone就是重写后的</li></ol><p>对request和respone的“重写”基本都是针对其headers，比如发送请求前未设置Accept-EncodingOkhttp会为你设置，在有cookie的情况下为你添加cookie，在拿到respone后如果需要解压缩Okhttp会为你自动解压缩。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>CacheInterceptor是缓存拦截器，主要作用是定义Okhttp的缓存机制。</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {  Response cacheCandidate = cache != null      ? cache.get(chain.request())      : null;//若当前有cache则根据请求获取对应的缓存  long now = System.currentTimeMillis();  //构造缓存策略  CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();  Request networkRequest = strategy.networkRequest;  Response cacheResponse = strategy.cacheResponse;  if (cache != null) {    cache.trackResponse(strategy);  }  if (cacheCandidate != null &amp;&amp; cacheResponse == null) {//有缓存但不可用关闭    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&#39;t applicable. Close it.  }  // If we&#39;re forbidden from using the network and the cache is insufficient, fail.  //如果设置禁止从网络获取响应且缓存不可用那么返回失败  if (networkRequest == null &amp;&amp; cacheResponse == null) {    return new Response.Builder()        .request(chain.request())        .protocol(Protocol.HTTP_1_1)        .code(504)        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)        .body(Util.EMPTY_RESPONSE)        .sentRequestAtMillis(-1L)        .receivedResponseAtMillis(System.currentTimeMillis())        .build();  }  // If we don&#39;t need the network, we&#39;re done.  //从cache获取respone不使用网络  if (networkRequest == null) {    return cacheResponse.newBuilder()        .cacheResponse(stripBody(cacheResponse))        .build();  }  Response networkResponse = null;  try {    networkResponse = chain.proceed(networkRequest);//调用下一个拦截器，从网络获取respone  } finally {    // If we&#39;re crashing on I/O or otherwise, don&#39;t leak the cache body.    if (networkResponse == null &amp;&amp; cacheCandidate != null) {      closeQuietly(cacheCandidate.body());    }  }  // If we have a cache response too, then we&#39;re doing a conditional get.  if (cacheResponse != null) {    if (networkResponse.code() == HTTP_NOT_MODIFIED) {//从网络获取respone且缓存非空 如果返回码为304 则更新缓存然后返回      Response response = cacheResponse.newBuilder()          .headers(combine(cacheResponse.headers(), networkResponse.headers()))          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())          .cacheResponse(stripBody(cacheResponse))          .networkResponse(stripBody(networkResponse))          .build();      networkResponse.body().close();      // Update the cache after combining headers but before stripping the      // Content-Encoding header (as performed by initContentStream()).      cache.trackConditionalCacheHit();      cache.update(cacheResponse, response);      return response;    } else {      closeQuietly(cacheResponse.body());    }  }  //没有缓存可供使用，读取网络响应构造respone  Response response = networkResponse.newBuilder()      .cacheResponse(stripBody(cacheResponse))      .networkResponse(stripBody(networkResponse))      .build();  if (cache != null) {//cache不为空 把respone缓存到cache    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) {      // Offer this request to the cache.      CacheRequest cacheRequest = cache.put(response);      return cacheWritingResponse(cacheRequest, response);    }    if (HttpMethod.invalidatesCache(networkRequest.method())) {      try {        cache.remove(networkRequest);      } catch (IOException ignored) {        // The cache cannot be written.      }    }  }  return response;}</code></pre><p>整个流程如下：</p><ol><li>判断是否有Cache，有的话根据request去尝试获取缓存</li><li>构造缓存策略</li><li>步骤1获取的缓存respone不为空但是不可用，关闭连接</li><li>设置禁止从网络获取响应且缓存不可用那么返回504失败</li><li>从cache获取respone 不使用网络（步骤1-5的作用就是在有请求时先尝试从本地获取缓存如果失败才会去从网络获取否则返回缓存）</li><li>调用下一个拦截器，从网络获取respone</li><li>从网络获取respone且缓存非空 如果返回码为304 则更新缓存然后返回</li><li>没有缓存可供使用，读取网络响应构造respone</li><li>cache不为空 把respone缓存到cache（步骤6-9作用就是从网络获取respone然后把获得的respone缓存到本地）</li></ol><p>CacheInterceptor中涉及两个类：Cache、CacheStrategy，这里先不展开分析，等分析Okhttp缓存机制时再做详细介绍。</p><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>ConnectInterceptor是连接拦截器，它的intercept函数非常简洁：</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Request request = realChain.request();  Transmitter transmitter = realChain.transmitter();//获取Transmitter  // We need the network to satisfy this request. Possibly for validating a conditional GET.  boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);  Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);//构造Exchange  return realChain.proceed(request, transmitter, exchange);//开启下一个拦截器调用并传入Transmitter、Exchange。}</code></pre><p>它首先获取Transmitter，然后通过Transmitter的newExchange方法创建一个Exchange，把它传到下一个拦截器。<br>Transmitter是应用和网络之间的一个桥梁，通过transmitter.newExchange构造一个Exchange实例</p><pre><code>Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) {  synchronized (connectionPool) {    if (noMoreExchanges) {      throw new IllegalStateException(&quot;released&quot;);    }    if (exchange != null) {      throw new IllegalStateException(&quot;cannot make a new request because the previous response &quot;          + &quot;is still open: please call response.close()&quot;);    }  }  ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);  Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec);  synchronized (connectionPool) {    this.exchange = result;    this.exchangeRequestDone = false;    this.exchangeResponseDone = false;    return result;  }}</code></pre><p>newExchange主要做了两件事：调用ExchangeFinder.find获取一个ExchangeCodec、构造一个Exchange。<br>ExchangeFinder就是负责连接的创建，把创建好的连接放入连接池，如果连接池中已经有该连接，就直接取出复用。而ExchangeCodec则是对HTTP请求和HTTP响应编码<br>Exchange则是用来进行发送和接收HTTP request和respone。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>CallServerInterceptor是拦截器链中最后一个拦截器，与服务器的交互如，发出请求和接收响应都是它完成的。</p><pre><code>@Override public Response intercept(Chain chain) throws IOException {  RealInterceptorChain realChain = (RealInterceptorChain) chain;  Exchange exchange = realChain.exchange();  Request request = realChain.request();  long sentRequestMillis = System.currentTimeMillis();  exchange.writeRequestHeaders(request);//向服务端写请求  boolean responseHeadersStarted = false;  Response.Builder responseBuilder = null;  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) {    // If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100    // Continue&quot; response before transmitting the request body. If we don&#39;t get that, return    // what we did get (such as a 4xx response) without ever transmitting the request body.    if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) {      exchange.flushRequest();      responseHeadersStarted = true;      exchange.responseHeadersStart();      responseBuilder = exchange.readResponseHeaders(true);    }    if (responseBuilder == null) {      if (request.body().isDuplex()) {        // Prepare a duplex body so that the application can send a request body later.        exchange.flushRequest();        BufferedSink bufferedRequestBody = Okio.buffer(            exchange.createRequestBody(request, true));        request.body().writeTo(bufferedRequestBody);      } else {        // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.        BufferedSink bufferedRequestBody = Okio.buffer(            exchange.createRequestBody(request, false));        request.body().writeTo(bufferedRequestBody);        bufferedRequestBody.close();      }    } else {      exchange.noRequestBody();      if (!exchange.connection().isMultiplexed()) {        // If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP/1 connection        // from being reused. Otherwise we&#39;re still obligated to transmit the request body to        // leave the connection in a consistent state.        exchange.noNewExchangesOnConnection();      }    }  } else {    exchange.noRequestBody();  }  if (request.body() == null || !request.body().isDuplex()) {    exchange.finishRequest();  }  if (!responseHeadersStarted) {    exchange.responseHeadersStart();//从服务端获取请求  }  if (responseBuilder == null) {    responseBuilder = exchange.readResponseHeaders(false);  }  Response response = responseBuilder      .request(request)      .handshake(exchange.connection().handshake())      .sentRequestAtMillis(sentRequestMillis)      .receivedResponseAtMillis(System.currentTimeMillis())      .build();  int code = response.code();  if (code == 100) {    // server sent a 100-continue even though we did not request one.    // try again to read the actual response    response = exchange.readResponseHeaders(false)        .request(request)        .handshake(exchange.connection().handshake())        .sentRequestAtMillis(sentRequestMillis)        .receivedResponseAtMillis(System.currentTimeMillis())        .build();    code = response.code();  }  exchange.responseHeadersEnd(response);  if (forWebSocket &amp;&amp; code == 101) {    // Connection is upgrading, but we need to ensure interceptors see a non-null response body.    response = response.newBuilder()        .body(Util.EMPTY_RESPONSE)        .build();  } else {    response = response.newBuilder()        .body(exchange.openResponseBody(response))        .build();  }  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))      || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) {    exchange.noNewExchangesOnConnection();  }  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) {    throw new ProtocolException(        &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());  }  return response;}</code></pre><p>在ConnectInterceptor中我们已经与服务器建立了连接，获取了输入输出流，所以CallServerInterceptor的intercept(Chain)方法逻辑就是把请求发送到服务器，然后获取服务器的响应。</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>通过Exchange的writeRequestHeaders(request)方法写入请求的header；如果请求的body不为空，通过okio写入请求的body。</p><h4 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h4><p>通过Exchange的readResponseHeaders(boolean)方法读取响应的header；通过Exchange的openResponseBody(Response)方法读取响应的body。</p><p>可以看出发送请求个获取响应都是通过exchange来进行的。</p><p>至此Okhttp的拦截器机制我们就分析完了，以上是Okhttp已经定义好的拦截器，在实际的使用中我们可以自定义拦截器来完成我们想要的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Okhttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Okhttp解析之--基本使用流程分析</title>
    <link href="/2019/11/12/Okhttp2/"/>
    <url>/2019/11/12/Okhttp2/</url>
    
    <content type="html"><![CDATA[<p>Okhttp解析系列</p><a id="more"></a><h1 id="Okhttp源码分析–基本使用流程分析"><a href="#Okhttp源码分析–基本使用流程分析" class="headerlink" title="Okhttp源码分析–基本使用流程分析"></a>Okhttp源码分析–基本使用流程分析</h1><h3 id="一、-使用"><a href="#一、-使用" class="headerlink" title="一、 使用"></a>一、 使用</h3><h5 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h5><pre><code>    OkHttpClient okHttpClient=new OkHttpClient();    Request request=new Request.Builder()        .get()        .url(&quot;www.baidu.com&quot;)        .build();    Call call =okHttpClient.newCall(request).execute();</code></pre><h5 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h5><pre><code>  OkHttpClient okHttpClient=new OkHttpClient();    Request request=new Request.Builder()        .get()        .url(&quot;www.baidu.com&quot;)        .build();    Call call=okHttpClient.newCall(request).enqueue(new Callback() {      @Override public void onFailure(Call call, IOException e) {        Log.i(TAG, &quot;onFailure: &quot;);      }      @Override public void onResponse(Call call, Response response) throws IOException {        Log.i(TAG, &quot;onResponse: &quot;);      }    });</code></pre><p>可以看出不管是同步还是异步请求，使用okhttp大致分为3个步骤：<br>     1. 创建okhttpclient<br>     2. 创建请求的request<br>     3. 通过client拿到call、发送请求</p><p><em>注：okhttpclient和request的创建均可采用构造者模式，在构造过程中可根据自己的实际需求设置相应的参数，如可在okhttpclient构造时添加自定义拦截器，在request构造过程中设置连接超时时间等。</em></p><h3 id="二、-源码分析"><a href="#二、-源码分析" class="headerlink" title="二、 源码分析"></a>二、 源码分析</h3><p>首先看下OkhttpClient这个类，使用步骤的第一步就是构造OkhttpClient对象。</p><p>先贴下官方对OkhttpClient的定义</p><pre><code> *Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their * responses. * OkHttpClients should be shared * OkHttp performs best when you create a single {@code OkHttpClient} instance and reuse it for * all of your HTTP calls. This is because each client holds its own connection pool and thread * pools. Reusing connections and threads reduces latency and saves memory. Conversely, creating a * client for each request wastes resources on idle pools.</code></pre><p>OkhttpClient是用于发送请求和读取响应的，官方建议创建一个单例的OkHttpClient，并且所有的http请求都复用它。因为每个OkHttpClient都有自己的connection pool and thread pool。复用connection pool and thread pool可以节约内存，相反如果为每个请求都创建一个OkHttpClient那么会浪费idle pools中的资源。</p><p>创建OkHttpClient有两种方式：<br>1、通过构造函数<br>2、通过Builder()创建一个client并自定义设置</p><p>同时还提供了一个newBuilder()来自定义client，它跟共享的client拥有相同的connection pool, thread pools, and configuration。我们可以用该方法来获取特定设置的client。</p><p>OkHttpClient提供无参构造函数，由代码可知它在内部调用OkHttpClient的有参构造函数<br>，在有参构造函数里对OkHttpClient主要属性做了初始化赋值。</p><pre><code>  public OkHttpClient() {    this(new Builder());  }  OkHttpClient(Builder builder) {    this.dispatcher = builder.dispatcher;    this.proxy = builder.proxy;    this.protocols = builder.protocols;    this.connectionSpecs = builder.connectionSpecs;    this.interceptors = Util.immutableList(builder.interceptors);    this.networkInterceptors = Util.immutableList(builder.networkInterceptors);    this.eventListenerFactory = builder.eventListenerFactory;    this.proxySelector = builder.proxySelector;    this.cookieJar = builder.cookieJar;    this.cache = builder.cache;    this.internalCache = builder.internalCache;    this.socketFactory = builder.socketFactory;    ...//省略N行  }</code></pre><p>下面贴下OkHttpClient主要的属性</p><pre><code>public class OkHttpClient{    final Dispatcher dispatcher;//分发器    final @Nullable Proxy proxy;//代理    final List&lt;Protocol&gt; protocols;//协议    final List&lt;ConnectionSpec&gt; connectionSpecs;//传输层版本和连接协议    final List&lt;Interceptor&gt; interceptors;//拦截器 （okhttp核心机制）    final List&lt;Interceptor&gt; networkInterceptors;//网络拦截器    final EventListener.Factory eventListenerFactory;    final ProxySelector proxySelector;//代理选择器    final CookieJar cookieJar;//cookie    final @Nullable    Cache cache;//cache 缓存    final @Nullable    InternalCache internalCache;//内部缓存    final SocketFactory socketFactory;//socket 工厂    final @Nullable    SSLSocketFactory sslSocketFactory;//安全套层socket工厂 用于https    final @Nullable    CertificateChainCleaner certificateChainCleaner;//验证确认响应书，适用HTTPS 请求连接的主机名    final HostnameVerifier hostnameVerifier;//主机名字确认    final CertificatePinner certificatePinner;//证书链    final Authenticator proxyAuthenticator;//代理身份验证    final Authenticator authenticator;//本地省份验证    final ConnectionPool connectionPool;//链接池 复用连接    final Dns dns; //域名    final boolean followSslRedirects;//安全套接层重定向    final boolean followRedirects;//本地重定向    final boolean retryOnConnectionFailure;//连接失败是否重试    final int connectTimeout;//连接超时时间    final int readTimeout;//读取超时时间    final int writeTimeout;//写入超时时间}</code></pre><p>通过浏览源码我们可以发现OkHttpClient采用了构造者设计模式，这样简化参数设置，降低使用成本。比如我们前面简单使用的例子</p><p>OkHttpClient类还有一个需要了解的函数就是newCall，因为OkHttpClient实现Call.Factory接口所以覆写了newCall方法，在方法内部返回的是一个RealCall实例。</p><pre><code>/**   * Prepares the {@code request} to be executed at some point in the future.   */  @Override public Call newCall(Request request) {    return RealCall.newRealCall(this, request, false /* for web socket */);  }</code></pre><p>OkHttpClient构造好了之后接下来就是创建request，request就是我们要发送的请求。它也是通过builder模式构造的。下面贴下Request的主要属性以及其构造函数。</p><pre><code>public final class Request {  final HttpUrl url;//请求url地址  final String method;//请求方式  final Headers headers;//请求头  final @Nullable RequestBody body;//请求body  final Map&lt;Class&lt;?&gt;, Object&gt; tags;//请求tags用来标记一类请求如 设置之后可以通过tags取消拥有该tag的请求  Request(Builder builder) {    this.url = builder.url;    this.method = builder.method;    this.headers = builder.headers.build();    this.body = builder.body;    this.tags = Util.immutableMap(builder.tags);  }  ...}</code></pre><p>通过Request我们可以得到我们想要的请求，然后下一步就是获取call实例然后发送请求。<br>在介绍OkHttpClient类的时候我们已经说过call对象是通过OkHttpClient的newCall方法获得的实际返回的是RealCall对象，也就是说真正发送的请求是RealCall，那么我们来看下RealCall这个类</p><pre><code>final class RealCall implements Call {  final OkHttpClient client; //realcall持有client  private Transmitter transmitter;//暂时不知道其作用  /** The application&#39;s original request unadulterated by redirects or auth headers. */  final Request originalRequest;//原始请求  final boolean forWebSocket;//  // Guarded by this.  private boolean executed;//请求是否执行标志位  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) { //构造函数    this.client = client;    this.originalRequest = originalRequest;    this.forWebSocket = forWebSocket;  }  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {//okhttpclient即通过该函数返回call    // Safely publish the Call instance to the EventListener.    RealCall call = new RealCall(client, originalRequest, forWebSocket);    call.transmitter = new Transmitter(client, call);    return call;  }</code></pre><p>RealCall实现的Call接口，其newCall函数内部通过RealCall的构造函数实例化一个call然后返回该call。<br>最后就是发送请求了，有两种方式：同步和异步。我们先看下同步请求的方式，同步请求是通过execute发送的</p><pre><code> @Override public Response execute() throws IOException {    synchronized (this) {//1      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);      executed = true;    }    transmitter.timeoutEnter();    transmitter.callStart();    try {      client.dispatcher().executed(this);//2      return getResponseWithInterceptorChain();//3    } finally {      client.dispatcher().finished(this);//4    }  }</code></pre><p>execute首先（注释1处）会synchronized来检查executed值从而确保每个请求只能执行一次。随后调用dispatcher的executed（注释2处）。<br>来看下Dispatcher这个类</p><pre><code>public final class Dispatcher {  private int maxRequests = 64;//最大请求数  private int maxRequestsPerHost = 5;//每个host的最大请求数  private @Nullable Runnable idleCallback;//请求队列空闲回调  /** Executes calls. Created lazily. */  private @Nullable ExecutorService executorService; //执行请求的线程池  /** Ready async calls in the order they&#39;ll be run. */  private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();//异步准备就绪请求队列  /** Running asynchronous(异步） calls. Includes canceled calls that haven&#39;t finished yet. */  private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();//异步执行请求队列  /** Running synchronous calls. Includes canceled calls that haven&#39;t finished yet. */  private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();//同步请求队列</code></pre><p>可以看出okhttp虽然支持并发请求但是有最大并发请求数的限制。而且okhttp针对不同的请求方式提供了不同的请求队列。dispatcher这个类主要的作用就是根据request的请求方式以及根据当前client的执行情况把新创建的call请求分发至不同的队列中去执行。</p><p>了解了dispatcher类作用我们看下它的exectued函数</p><pre><code> synchronized void executed(RealCall call) {    runningSyncCalls.add(call);  }</code></pre><p>很简单它只是把传入的call对象添加到同步请求队列中（runningSyncCalls）。那请求具体是如何发送的呢 我们接着看RealCall的exectued函数。<br>在注释3处通过调用getResponseWithInterceptorChain()获取respone并返回该respone。</p><pre><code> Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    interceptors.addAll(client.interceptors());//如果在client中设置了自定义interceptor那么会放到interceptors中    interceptors.add(new RetryAndFollowUpInterceptor(client));//添加重试与重定向拦截器    interceptors.add(new BridgeInterceptor(client.cookieJar()));//添加桥接拦截器    interceptors.add(new CacheInterceptor(client.internalCache()));//添加缓存拦截器    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {      interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(forWebSocket));//添加CallServer拦截器    Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0,        originalRequest, this, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());//        创建RealInterceptorChain实例，把interceptors传入    boolean calledNoMoreExchanges = false;    try {      Response response = chain.proceed(originalRequest);//通过proceed链式获取respone      if (transmitter.isCanceled()) {        closeQuietly(response);        throw new IOException(&quot;Canceled&quot;);      }      return response;//返回respone    } catch (IOException e) {      calledNoMoreExchanges = true;      throw transmitter.noMoreExchanges(e);    } finally {      if (!calledNoMoreExchanges) {        transmitter.noMoreExchanges(null);      }    }  }</code></pre><p>getResponseWithInterceptorChain首先会把自定义以及okhttp定义的拦截器加到interceptors的list中，然后构造RealInterceptorChain拦截器链，调用chain.proceed链式调用各个拦截器并最终获得respone。</p><p>Interceptor可以说是okhttp的核心机制之一，我们一起来看下</p><pre><code>public interface Interceptor {  Response intercept(Chain chain) throws IOException;  interface Chain {    Request request();    Response proceed(Request request) throws IOException;    /**     * Returns the connection the request will be executed on. This is only available in the chains     * of network interceptors; for application interceptors this is always null.     */    @Nullable Connection connection();    Call call();    int connectTimeoutMillis();    Chain withConnectTimeout(int timeout, TimeUnit unit);    int readTimeoutMillis();    Chain withReadTimeout(int timeout, TimeUnit unit);    int writeTimeoutMillis();    Chain withWriteTimeout(int timeout, TimeUnit unit);  }}</code></pre><p>它是okhttp定义的一个接口类，并且okhttp提供了5个实现类，他们就是getResponseWithInterceptorChain()中添加到interceptors中的5个Interceptor，他们作用各不相同，这个以后会单独分析。除此之外我们还可以自定义自己的拦截器。<br>了解了拦截器的概念之后我们看下RealInterceptorChain及其proceed函数</p><pre><code>public final class RealInterceptorChain implements Interceptor.Chain {  private final List&lt;Interceptor&gt; interceptors;//拦截器list  private final Transmitter transmitter;  private final @Nullable Exchange exchange;  private final int index;  private final Request request;//请求  private final Call call;  private final int connectTimeout;  private final int readTimeout;  private final int writeTimeout;  private int calls;  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, Transmitter transmitter,      @Nullable Exchange exchange, int index, Request request, Call call,      int connectTimeout, int readTimeout, int writeTimeout) {//构造函数    this.interceptors = interceptors;    this.transmitter = transmitter;    this.exchange = exchange;    this.index = index;    this.request = request;    this.call = call;    this.connectTimeout = connectTimeout;    this.readTimeout = readTimeout;    this.writeTimeout = writeTimeout;  }@Override public Response proceed(Request request) throws IOException {//proceed方法实际调用同名的proceed方法    return proceed(request, transmitter, exchange);  }  public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange)      throws IOException {//1    if (index &gt;= interceptors.size()) throw new AssertionError();    calls++;    // If we already have a stream, confirm that the incoming request will use it.    if (this.exchange != null &amp;&amp; !this.exchange.connection().supportsUrl(request.url())) {      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)          + &quot; must retain the same host and port&quot;);    }    // If we already have a stream, confirm that this is the only call to chain.proceed().    if (this.exchange != null &amp;&amp; calls &gt; 1) {      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)          + &quot; must call proceed() exactly once&quot;);    }    // 2    //Call the next interceptor in the chain.    RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange,        index + 1, request, call, connectTimeout, readTimeout, writeTimeout);    Interceptor interceptor = interceptors.get(index);    Response response = interceptor.intercept(next);    // Confirm that the next interceptor made its required call to chain.proceed().    if (exchange != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) {      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor          + &quot; must call proceed() exactly once&quot;);    }    // Confirm that the intercepted response isn&#39;t null.    if (response == null) {      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);    }    if (response.body() == null) {      throw new IllegalStateException(          &quot;interceptor &quot; + interceptor + &quot; returned a response with no body&quot;);    }    return response;  }</code></pre><p>RealInterceptorChain作为拦截器链它持有整个应用的拦截器以及网络拦截器。该类的proceed方法实际是调用了该类重载的proceed方法（注释1处）。在注释2处，调用拦截器链中的下一个拦截器。在这里new了一个RealInterceptorChain，注意这里传入的index加了1（getResponseWithInterceptorChain传入的index为0），这代表拦截器链中的下一个拦截器的index，之后根据index获取当前的拦截器并调用其intercept方法。intercept是接口Interceptor的一个方法，由具体的实现类实现，此处我们以RetryAndFollowUpInterceptor为例看下intercept方法中做了什么事情。</p><pre><code>public final class RetryAndFollowUpInterceptor implements Interceptor {  private final OkHttpClient client;//持有的client@Override public Response intercept(Chain chain) throws IOException {    Request request = chain.request();//获取传入的chain的request 此处的request是next的request    RealInterceptorChain realChain = (RealInterceptorChain) chain;    Transmitter transmitter = realChain.transmitter();    int followUpCount = 0;    Response priorResponse = null;    while (true) {      transmitter.prepareToConnect(request);      if (transmitter.isCanceled()) {        throw new IOException(&quot;Canceled&quot;);      }      Response response;      boolean success = false;      try {        response = realChain.proceed(request, transmitter, null);//调用next的proceed方法        success = true;      } catch (RouteException e) {        // The attempt to connect via a route failed. The request will not have been sent.        if (!recover(e.getLastConnectException(), transmitter, false, request)) {          throw e.getFirstConnectException();        }        continue;      } catch (IOException e) {        // An attempt to communicate with a server failed. The request may have been sent.        boolean requestSendStarted = !(e instanceof ConnectionShutdownException);        if (!recover(e, transmitter, requestSendStarted, request)) throw e;        continue;      } finally {        // The network call threw an exception. Release any resources.        if (!success) {          transmitter.exchangeDoneDueToException();        }      }      // Attach the prior response if it exists. Such responses never have a body.      if (priorResponse != null) {        response = response.newBuilder()            .priorResponse(priorResponse.newBuilder()                    .body(null)                    .build())            .build();      }      Exchange exchange = Internal.instance.exchange(response);      Route route = exchange != null ? exchange.connection().route() : null;      Request followUp = followUpRequest(response, route);//处理请求重定向      if (followUp == null) {        if (exchange != null &amp;&amp; exchange.isDuplex()) {          transmitter.timeoutEarlyExit();        }        return response;//直到没有重定向之后返回respone      }      RequestBody followUpBody = followUp.body();      if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) {        return response;      }      closeQuietly(response.body());      if (transmitter.hasExchange()) {        exchange.detachWithViolence();      }      if (++followUpCount &gt; MAX_FOLLOW_UPS) {        throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);      }      request = followUp;      priorResponse = response;    }  }}</code></pre><p>我们看到在RetryAndFollowUpInterceptor的intercept方法中会调用传入的next（即拦截器链中当前拦截器的下一个拦截器）的proceed方法，这样就可以链式的依次调用chain中所有拦截器，每个拦截器都执行自己的任务最终返回respone。该respone通过RealCall的getResponseWithInterceptorChain返回到execute方法并最终变成我们获得的respone。至此同步请求获得了respone，最后的操作就是在RealCall的execute方法中调用finished方法</p><pre><code> @Override public Response execute() throws IOException {    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);      executed = true;    }    transmitter.timeoutEnter();    transmitter.callStart();    try {      client.dispatcher().executed(this);      return getResponseWithInterceptorChain();    } finally {      client.dispatcher().finished(this);//拿到respone后调用finish方法    }  }</code></pre><p>该方法是dispatcher提供的</p><pre><code> void finished(RealCall call) {    finished(runningSyncCalls, call);  }  private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) {    Runnable idleCallback;    synchronized (this) {      if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#39;t in-flight!&quot;);//从同步执行队列移除该call 移除失败会抛出异常      idleCallback = this.idleCallback;    }    boolean isRunning = promoteAndExecute();//1    if (!isRunning &amp;&amp; idleCallback != null) {      idleCallback.run();//如果isRuning为false并且idleCallback不为空就执行idleCallback。    }  }</code></pre><p>我们看下promoteAndExecute()这个方法</p><pre><code>private boolean promoteAndExecute() {  assert (!Thread.holdsLock(this));  List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();  boolean isRunning;  synchronized (this) {    for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {//1      AsyncCall asyncCall = i.next();      if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity.      if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity.      i.remove();      asyncCall.callsPerHost().incrementAndGet();      executableCalls.add(asyncCall);      runningAsyncCalls.add(asyncCall);    }    isRunning = runningCallsCount() &gt; 0;  }  for (int i = 0, size = executableCalls.size(); i &lt; size; i++) {//2    AsyncCall asyncCall = executableCalls.get(i);    asyncCall.executeOn(executorService());  }  return isRunning;}</code></pre><p>该方法主要是两个for循环，首先第一个for循环（注释1处）遍历准备就绪队列如果不为空且满足一定条件则添加到executableCalls中，但是在同步请求时准备就绪队列（readyAsyncCalls）为空，executableCalls也为空，所以两个for循环都不会进入（实际上该方法是为异步请求准备的）函数最终返回false。</p><p>此时回到dispatcher的finish（）方法，它会判断promoteAndExecute()返回值和idleCallback是否为空，如果isRuning为false并且idleCallback不为空就执行idleCallback，否则就什么都不做。</p><p>至此同步请求流程分析完毕。</p><h5 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h5><p>异步请求跟同步请求不同的地方就是它是调用RealCall的enqueue方法</p><pre><code>@Override public void enqueue(Callback responseCallback) {    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);      executed = true;    }    transmitter.callStart();    client.dispatcher().enqueue(new AsyncCall(responseCallback));//执行dispatcher的enqueue  }</code></pre><p>在方法内部调用dispatcher的enqueue并传入AsyncCall参数，我们先来看下AsyncCall再分析异步请求流程</p><pre><code>final class AsyncCall extends NamedRunnable {  private final Callback responseCallback;  private volatile AtomicInteger callsPerHost = new AtomicInteger(0);  AsyncCall(Callback responseCallback) {    super(&quot;OkHttp %s&quot;, redactedUrl());    this.responseCallback = responseCallback;  }}</code></pre><p>AsyncCall是RealCall的一个内部类它继承自NamedRunnable</p><pre><code>public abstract class NamedRunnable implements Runnable {  protected final String name;  public NamedRunnable(String format, Object... args) {    this.name = Util.format(format, args);  }  @Override public final void run() {    String oldName = Thread.currentThread().getName();    Thread.currentThread().setName(name);    try {      execute();    } finally {      Thread.currentThread().setName(oldName);    }  }  protected abstract void execute();}</code></pre><p>NamedRunnable其实就是一个实现Runnable的线程类。在它的run方法中调用了其提供的抽象函数execute()，execute()的实现是在AsyncCall</p><pre><code>@Override protected void execute() {  boolean signalledCallback = false;  transmitter.timeoutEnter();  try {    Response response = getResponseWithInterceptorChain();    signalledCallback = true;    responseCallback.onResponse(RealCall.this, response);  } catch (IOException e) {    if (signalledCallback) {      // Do not signal the callback twice!      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);    } else {      responseCallback.onFailure(RealCall.this, e);    }  } finally {    client.dispatcher().finished(this);  }}</code></pre><p>可以看到这跟同步请求的过程是一样的先通过getResponseWithInterceptorChain()链式调用拦截链去获得resopne，之后是通过callback回调结果，最后调用finished。<br>分析AsyncCall之后我们可以大致猜测出异步请求的实现是通过线程去执行Call，请求的执行过程跟同步请求是一样的只不过最后是通过callbcak返回。</p><p>好了，我们来看下具体的异步请求流程，之前说到dispatcher的enqueue方法，那我们来看下这个方法都做了什么</p><pre><code> void enqueue(AsyncCall call) {    synchronized (this) {      readyAsyncCalls.add(call);//添加到异步准备就绪队列      // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to      // the same host.      if (!call.get().forWebSocket) {        AsyncCall existingCall = findExistingCallWithHost(call.host());        if (existingCall != null) call.reuseCallsPerHostFrom(existingCall);      }    }    promoteAndExecute();//执行请求  }</code></pre><p>很简单在方法内部先是把call添加到异步准备就绪队列然后调用了 promoteAndExecute，promoteAndExecute我们之前在同步请求分析过它内部主要是两个for循环，在同步请求时这两个for循环都是不满足条件的，那我们看下异步请求时</p><pre><code>private boolean promoteAndExecute() {    assert (!Thread.holdsLock(this));    List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;();    boolean isRunning;    synchronized (this) {      for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {//把异步准备就绪对列中的call取出        AsyncCall asyncCall = i.next();        //判断最大请求数以及每个host请求数是否符合要求        if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity.        if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity.        //移除准备就绪队列中的call        i.remove();        asyncCall.callsPerHost().incrementAndGet();//记录该call的host的请求数        executableCalls.add(asyncCall);//添加到executableCalls        runningAsyncCalls.add(asyncCall);//添加到异步执行队列      }      isRunning = runningCallsCount() &gt; 0;    }    for (int i = 0, size = executableCalls.size(); i &lt; size; i++) {//executableCalls不为空，取出执行      AsyncCall asyncCall = executableCalls.get(i);      asyncCall.executeOn(executorService());//call实际执行    }    return isRunning;  }</code></pre><p>因为在之前已经把call添加到了异步准备就绪队列（readyAsyncCalls<br>），所以第一个for是可以进入的，在第一个for循环内部首先会先判断当前准备就绪队列中的call是否达到了最大请求数即最大并发请求数，然后判断单个host是否达到最大请求数。之后就是把当前的call添加到executableCalls和runningAsyncCalls两个队列中。之后进入第二个for循环，在这个for循环中依次其中取出call对象并调用其executeO函数。<br>注意在execute函数中传入的executorService其实是一个线程池</p><pre><code>public synchronized ExecutorService executorService() {  if (executorService == null) {    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,        new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));  }  return executorService;}</code></pre><p>可以看出executorService是一个仅有非核心线程，且非核心线程数无限大的线程池。<br>好了简单了解了executorService我们返回来接着看下executeOn，<br>在executeOn中调用了executorService.execute(this)，executeOn是AsyncCall内部的函数而AsyncCall是一个线程类所以该操作会执行线程的run方法，这里具体来说就是NamedRunnable的run方法，我们知道在这个run方法中调用了execute()方法，execute()我们上面分析过了跟同步请求过程一样链式调用拦截器最终获取respone。</p><pre><code>  void executeOn(ExecutorService executorService) {      assert (!Thread.holdsLock(client.dispatcher()));      boolean success = false;      try {        executorService.execute(this);//实际执行call        success = true;      } catch (RejectedExecutionException e) {        InterruptedIOException ioException = new InterruptedIOException(&quot;executor rejected&quot;);        ioException.initCause(e);        transmitter.noMoreExchanges(ioException);        responseCallback.onFailure(RealCall.this, ioException);      } finally {        if (!success) {          client.dispatcher().finished(this); // This call is no longer running!        }      }    }</code></pre><p>至此异步请求流程也分析完了。</p><p>最后我们来总结下Okhttp的请求流程：<br>首先不管同步还是异步都会先初始化一个OkhttpClient之后是Request、Call。<br>不同之处在于同步请求把请求添加到runningSyncCalls<br>然后直接调用execute，链式调用拦截器获取respone并返回。异步请求则是把请求先添加到readyAsyncCalls，之后执行的时候再把其添加到runningAsyncCalls并且把请求放到子线程中取执行，即链式调用拦截器获取respone是在子线程中完成的。<br>还有就是不管是同步还是异步请求完成后都会把Call移除。<br>以上只是Okhttp最简单的流程分析，其实Okhttp还有很多值得我们学习的地方，之后我会继续更新相关内容来更深入了解Okhttp。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Okhttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Okhttp解析之—Okhttp概览</title>
    <link href="/2019/11/10/Okhttp1/"/>
    <url>/2019/11/10/Okhttp1/</url>
    
    <content type="html"><![CDATA[<p>Okhttp解析系列</p><a id="more"></a><h1 id="Okhttp解析—Okhttp概览"><a href="#Okhttp解析—Okhttp概览" class="headerlink" title="Okhttp解析—Okhttp概览"></a>Okhttp解析—Okhttp概览</h1><p>Okhttp作为目前Android使用最为广泛的网络框架之一，我们有必要去深入了解一下，本文是Okhttp解析的第一篇，主要是从宏观上认识Okhttp整个架构是如何实现的。</p><h2 id="一、什么是Okhttp"><a href="#一、什么是Okhttp" class="headerlink" title="一、什么是Okhttp"></a>一、什么是Okhttp</h2><p>HTTP是当今应用程序通过网络交换数据和媒体的方式。 有效地使用 HTTP 可以使应用加载得更快并节省带宽。<br>Okhttp是一个高效的HTTP Client，高效性体现在：</p><ul><li>Http / 2支持允许对同一主机的所有请求共享一个套接字</li><li>连接池减少了请求延迟</li><li>透明 GZIP 缩小了下载大小</li><li>对于重复请求，响应缓存可以完全避免网络请求</li></ul><p>当网络出现问题时，OkHttp 不会立即结束: 它会默默地从常见的连接问题中恢复过来。 如果您的服务有多个 IP 地址，如果第一次连接失败，OkHttp 将尝试替代地址。 这对于 IPv4 + IPv6和承载于冗余数据中心的服务是必要的。 Okhttp 支持现代 TLS 特性(TLS 1.3、 ALPN、证书ping)。 它可以配置为回退到可用的连接。<br>并且Okhttp是易用的，其通过Builder模式设计请求 / 响应 API，支持同步阻塞调用和带回调的异步调用。</p><h2 id="二、Okhttp的请求机制以及相关概念"><a href="#二、Okhttp的请求机制以及相关概念" class="headerlink" title="二、Okhttp的请求机制以及相关概念"></a>二、Okhttp的请求机制以及相关概念</h2><p>首先我们来了解下HTTP client、request、response。<br>HTTP client的作用就是接受我们的request并返回response。<br>request通常包含一个 URL, 一个方法 (比如GET/POST), 以及一个headers列表还可能包含一个body（特定内容类型的数据流）。<br>response则通常用响应代码(比如200表示成功，404表示未找到)、headers和可选的body来回答request。</p><p>我们日常使用http都是按以下步骤：<br>1、创建httpClient<br>2、创建request<br>3、使用httpClient请求request然后获取respone</p><p>使用Okhttp也是如此，我们创建OkhttpClient然后把Reques交给它，最后拿到Respone，但是Okhttp在内部实际进行http请求时并不是这样简单的拿Request去请求然后获得Resopne返回。</p><p>下面就来看下Okhttp的请求机制，可以概括为以下流程：</p><ol><li>当我们创建OkhttpClient然后把Reques交给它之后，Okhttp为了提高正确性和效率在传输请求之前会重写请求。</li><li>然后Okhttp会尝试连接webserver，我们知道request中是带有URL的但是Okhttp在连接webserver时不仅仅使用URL它还会用Address和Route。连接webserver成功后获取respone，连接webserver失败Okhttp会进行重试操作。</li><li>在把respone返回给client之前Okhttp一般还会重写respone以及缓存respone。还有就是如果请求过程中产生重定向Okhttp也会进行处理并返回最终的respone。<br>上边就是Okhttp的请求以及返回的大致流程 </li></ol><h3 id="Rewriting-Requests"><a href="#Rewriting-Requests" class="headerlink" title="Rewriting Requests"></a>Rewriting Requests</h3><p>Okhttp 可以添加原始请求中缺少的headers，包括Content-Length,Transfer-Encoding,User-Agent ,Host ,Connection , 和Content-Type。 除非Accept-Encoding头已经存在，否则它将添加一个用于透明响应压缩的 Accept-Encoding 头。 如果你有 cookies，OkHttp 会添加一个 Cookie 头。</p><p>有些请求会有一个缓存response。 当这个缓存过期，OkHttp 可以执行一个有条件的 GET 来下载新的response，这需要添加如 If-Modified-Since 和 If-None-Match 这样的headers。</p><h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><p>Okhttp连接webserver时使用了URL、Address和Route。</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>Url是 HTTP 和互联网的基础，每个 URL 标识一个特定的路径。它是一个通用的，分散的网络命名方案，它指定了如何访问网络资源、指定调用是纯文本(http) 或加密(https)方式。它们没有指定是否应该使用特定的代理服务器或者如何通过该代理服务器的身份验证</p><h4 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h4><p>Address指定一个 web 服务器(比如 github. com)和连接到该服务器所需的所有静态配置: 端口号、 HTTPS 设置和首选网络协议(比如 http / 2或 SPDY)。</p><p>具有相同Address的 url 也可能有相同的底层 TCP 套接字连接。 共享一个连接有很大的性能优势比如更低的延迟，更高的吞吐量(由于 TCP 缓慢启动)和节省电池。 Okhttp 使用一个 ConnectionPool 自动重用 http / 1.x 连接以及多路传输 http / 2和 SPDY 连接。<br>在 OkHttp 中，Address的一些字段来自 URL (scheme, hostname, port) ，其余字段来自 OkHttpClient。</p><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p>Route提供实际连接到网络服务器所需的动态信息。 它会尝试的特定 IP 地址(由 DNS 查询发现)、使用的准确代理服务器(如果使用 ProxySelector)以及协商的 TLS 版本(用于 HTTPS 连接)。<br>一个地址可能有多条Route。 例如，承载于多个数据中心的 web 服务器在其 DNS 响应中可能会产生多个 IP 地址。</p><p>当你使用 OkHttp 请求一个 URL 时，它是这样做的:</p><ol><li>它使用 URL 并配置 OkHttpClient 来创建一个address。 这个address指定了我们如何连接到网络服务器</li><li>它试图从连接池（connection pool）中检索具有该地址的连接</li><li>如果它没有在连接池中找到连接，它会选择一条route进行尝试。 这通常意味着发出 DNS 请求来获取服务器的 IP 地址。 然后，如果有需要，它会选择一个 TLS 版本和代理服务器</li><li>如果是一个新的route，则通过构建直接的套接字连接、 TLS 隧道(通过 HTTP 代理使用 HTTPS)或直接的 TLS 连接进行连接。 必要时，它会进行 TLS 握手</li><li>发送 HTTP 请求并读取respone</li></ol><p>如果连接有问题，OkHttp 会选择另一条route，再试一次。 这让 OkHttp 在服务器地址的一个子集无法访问时从错误中恢复。 当池连接过时或者不支持当前使用的 TLS 版本时，它也很有用。<br>一旦接收到respone，连接将返回到池中，以便可以在将来的请求中重用它。 连接在一段时间的不活动会被从连接池中清除。</p><h3 id="Rewriting-Response"><a href="#Rewriting-Response" class="headerlink" title="Rewriting Response"></a>Rewriting Response</h3><p>如果使用透明压缩，OkHttp 将删除相应的 Content-Encoding 和 Content-Length，因为它们不适用于解压缩的响应体。<br>如果条件 GET请求 成功，来自网络和缓存的respone将按照规范的指示进行合并。</p><h3 id="Follow-up-Requests"><a href="#Follow-up-Requests" class="headerlink" title="Follow-up Requests"></a>Follow-up Requests</h3><p>当你请求的 URL 被重定向，webserver 将返回一个响应代码，比如302来指示新 URL。Okhttp将会重定向检索最终的respone。<br>如果respone发出了一个授权验证，OkHttp 将要求 Authenticator (如果配置了一个)满足这个验证。 如果身份验证者提供了凭据，那么request会携带该凭据去重试。</p><h3 id="Retrying-Requests"><a href="#Retrying-Requests" class="headerlink" title="Retrying Requests"></a>Retrying Requests</h3><p>有时候连接会失败（比如池连接过时并断开连接或无法连接到网络服务器本身）如果此时有一个可用的Route，OkHttp 会用该Route重试请求。</p><p>Okhttp在实现流程的时候还引入了一些概念比如Call、Interceptors、ConnectionSpec、Events等等。</p><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p>经过重写、重定向、重试等操作，简单请求可能会产生许多请求和响应。 Okhttp 使用 Call 来封装表示request，Call就是一个已经准备好可以执行的请求。如果 url 被重定向，或者故障转移到另一个 IP 地址，那么代码将继续工作，直至返回最终respone。</p><p>Call有两种调用方式：<br>同步：线程阻塞直到响应可读为止<br>异步: 可以在任何线程上对请求进行排队，当响应可读时在另一个线程上被调回<br>可以从任何线程取消Call调用， 这将导致调用失败。在写入请求body或读取响应body时调用cancel会抛出IOException。</p><h3 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h3><p>Dispatcher调度器，它实际就是负责Okhttp请求策略。<br>对于同步调用，调用请求的线程自己负责管理同时发出的请求数量。但是要注意的是太多的并发请求会浪费资源; 太少也不好。<br> 对于异步调用，Dispatcher 实现最大并发请求的策略。 它设置了每个 web 服务器的最大值并发请求数为5，总并发数为64。当然我们也可以自行设置并发数。</p><h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><p>拦截器可以说是Okhttp的精髓之一，它是一种强大的机制，它可以监测、重写和重试Call调用。系统提供了5种已经定义好的拦截器，上面说的request/respone 重写，失败重试等都是在拦截器中完成的。<br>对 chain.proceed (request)的调用是每个拦截器实现的关键部分。 这个简单的外观方法是所有拦截器完成其功能的地方，并且还生成满足请求的响应。 注意如果 chain.proceed (request)被调用多次，则必须关闭以前的响应body。<br>实际使用过程是通过拦截器链把拦截器链起来然后按顺序调用拦截器。<br><img src="https://square.github.io/okhttp/images/interceptors@2x.png" srcset="/img/loading.gif" alt="interceptor"></p><p>Okhttp拦截器分为2类：Application Interceptors和Network Interceptors。</p><p>这两类拦截器本质上没有区别只是它们作用的时机不同。由上图我们可以看出Application Interceptors作用于Okhttp Core之前而Network Interceptors则作用于Okhttp Core之后。我的理解就是Application Interceptors调用是在请求发出之前，Network Interceptors则是在请求发出后与webserver连接的过程。<br>每种拦截器链都有其优点：<br><strong>Application interceptors</strong></p><ul><li><p>不必担心重定向和重试之类的中间响应</p></li><li><p>总是调用一次，即使 HTTP 响应是从缓存中提供的</p></li><li><p>关注应用程序的原始意图，而不关注OkHttp注入的headers</p></li><li><p>允许短路和不调用Chain.proceed().</p></li><li><p>允许重试并多次调用Chain.proceed().</p></li><li><p><em>Network Interceptors*</em></p></li><li><p>能够操作中间respone，如重定向和重试</p></li><li><p>不会为短路网络的缓存响应调用</p></li><li><p>仅当数据将要通过网络传输时才会关注</p></li><li><p>允许带有Connection请求<br>最后补充两个示例：<br>使用Interceptor重写请求</p><pre><code>/** This interceptor compresses the HTTP request body. Many webservers can&#39;t handle this! */final class GzipRequestInterceptor implements Interceptor {@Override public Response intercept(Interceptor.Chain chain) throws IOException {  Request originalRequest = chain.request();  if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) {    return chain.proceed(originalRequest);  }  Request compressedRequest = originalRequest.newBuilder()      .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)      .method(originalRequest.method(), gzip(originalRequest.body()))      .build();  return chain.proceed(compressedRequest);}private RequestBody gzip(final RequestBody body) {  return new RequestBody() {    @Override public MediaType contentType() {      return body.contentType();    }    @Override public long contentLength() {      return -1; // We don&#39;t know the compressed length in advance!    }    @Override public void writeTo(BufferedSink sink) throws IOException {      BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));      body.writeTo(gzipSink);      gzipSink.close();    }  };}}</code></pre></li></ul><pre><code>使用Interceptor重写响应</code></pre><p>/** Dangerous interceptor that rewrites the server’s cache-control header. */<br>private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() {<br>  @Override public Response intercept(Interceptor.Chain chain) throws IOException {<br>    Response originalResponse = chain.proceed(chain.request());<br>    return originalResponse.newBuilder()<br>        .header(“Cache-Control”, “max-age=60”)<br>        .build();<br>  }<br>};</p><pre><code>### ConnectionSpecConnectionSpec的引入是为了HTTPS，在协商与 HTTPS 服务器的连接时，OkHttp 需要知道要提供哪些 TLS 版本和密码套件。Okhttp为了与尽可能多的主机连接的同时保证连接的安全性引入ConnectionSpec，它实现了特定的安全性和连接性决策，Okhttp 包括四个内置的连接规范RESTRICTED_TLS、MODERN_TLS、COMPATIBLE_TLS、CLEARTEXT。默认情况下，OkHttp 将尝试建立一个 MODERN_TLS 连接。 但是，通过配置client的 connectionSpecs，如果 MODERN_TLS失败，回退到 COMPATIBLE_TLS 连接。</code></pre><p>OkHttpClient client = new OkHttpClient.Builder()<br>    .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))<br>    .build();</p><pre><code>### EventsEvents的引入是为了监控call请求，因为我们有必要了解我们应用的HTTP请求。具体来说就是监控以下内容：应用程序 HTTP 请求调用的频率和请求大小。 基础网络的性能监控，如果网络差你应该减少请求或者改善网络。#### **EventListener**Okhttp提供了EventListener，我们可以继承它并重写我们感兴趣的方法来进行Event的监控。![Evnets](https://square.github.io/okhttp/images/events@2x.png)上图是在没有重试和重定向的情况下EventListener所能监控的Events流。下面是对应的代码</code></pre><p>class PrintingEventListener extends EventListener {<br>  private long callStartNanos;</p><p>  private void printEvent(String name) {<br>    long nowNanos = System.nanoTime();<br>    if (name.equals(“callStart”)) {<br>      callStartNanos = nowNanos;<br>    }<br>    long elapsedNanos = nowNanos - callStartNanos;<br>    System.out.printf(“%.3f %s%n”, elapsedNanos / 1000000000d, name);<br>  }</p><p>  @Override public void callStart(Call call) {<br>    printEvent(“callStart”);<br>  }</p><p>  @Override public void callEnd(Call call) {<br>    printEvent(“callEnd”);<br>  }</p><p>  @Override public void dnsStart(Call call, String domainName) {<br>    printEvent(“dnsStart”);<br>  }</p><p>  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {<br>    printEvent(“dnsEnd”);<br>  }</p><p>  …<br>}</p><pre><code>#### **Eventlistener. Factory**上面Eventlistener只适用于没有并发的情况，如果有多个请求并发执行我们需要使用Eventlistener. Factory来给每个请求创建一个Eventlistener。下面是一个给每个请求创建一个带唯一ID的Eventlistener的示例：</code></pre><p>class PrintingEventListener extends EventListener {<br>  public static final Factory FACTORY = new Factory() {<br>    final AtomicLong nextCallId = new AtomicLong(1L);</p><pre><code>@Override public EventListener create(Call call) {  long callId = nextCallId.getAndIncrement();  System.out.printf(&quot;%04d %s%n&quot;, callId, call.request().url());  return new PrintingEventListener(callId, System.nanoTime());}</code></pre><p>  };</p><p>  final long callId;<br>  final long callStartNanos;</p><p>  public PrintingEventListener(long callId, long callStartNanos) {<br>    this.callId = callId;<br>    this.callStartNanos = callStartNanos;<br>  }</p><p>  private void printEvent(String name) {<br>    long elapsedNanos = System.nanoTime() - callStartNanos;<br>    System.out.printf(“%04d %.3f %s%n”, callId, elapsedNanos / 1000000000d, name);<br>  }</p><p>  @Override public void callStart(Call call) {<br>    printEvent(“callStart”);<br>  }</p><p>  @Override public void callEnd(Call call) {<br>    printEvent(“callEnd”);<br>  }</p><p>  …<br>}</p><pre><code>上面说的都是请求正常时event，接下来说下非正常情况下的event流程。#### **Events with Failures**当请求失败时，将调用一个失败方法 connectFailed () ，用于在建立到服务器的连接时发生故障，当 HTTP 请求永久失败时调用 callFailed ()。 当发生故障时，有可能开始事件没有相应的结束事件。![event](https://square.github.io/okhttp/images/events_with_failures@2x.png)#### **Events with Retries and Follow-Ups**Okhttp是健壮的，可以从一些连接故障中自动恢复。 在这种情况下，connectFailed ()事件不是终结符，后面不跟 callFailed ()。 当尝试重试时，事件侦听器将收到多个相同类型的事件。单个 HTTP 调用可能需要发出后续请求来处理身份验证、重定向和 HTTP 层超时。 在这种情况下，可以尝试多个连接、请求和响应。 重定向是单个请求可能触发同一类型多个事件的另一个原因。![event](https://square.github.io/okhttp/images/events_with_failures_and_retries@2x.png)以上就是本文全部内容，接下来就是源码分析了，不过建议在看源码前把Okhttp的整个运行过程以及其中涉及的概念搞懂这样看源码才会事半功倍。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Okhttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent知识详解</title>
    <link href="/2019/11/01/IntentDK/"/>
    <url>/2019/11/01/IntentDK/</url>
    
    <content type="html"><![CDATA[<h1 id="Intent知识详解"><a href="#Intent知识详解" class="headerlink" title="Intent知识详解"></a>Intent知识详解</h1><h2 id="一、什么是Intent"><a href="#一、什么是Intent" class="headerlink" title="一、什么是Intent"></a>一、什么是Intent</h2><p>贴一个官方解释：</p><blockquote><p>An intent is an abstract description of an operation to be performed. It can be used with <a href="https://developer.android.google.cn/reference/kotlin/android/content/Context.html#startActivity(android.content.Intent)" target="_blank" rel="noopener">Context#startActivity(Intent)</a> to launch an <a href="https://developer.android.google.cn/reference/kotlin/android/app/Activity.html" target="_blank" rel="noopener">android.app.Activity</a> , <a href="https://developer.android.google.cn/reference/kotlin/android/content/Context.html#sendBroadcast(android.content.Intent)" target="_blank" rel="noopener">broadcastIntent</a> to send it to any interested <a href="https://developer.android.google.cn/reference/kotlin/android/content/BroadcastReceiver.html" target="_blank" rel="noopener">BroadcastReceiver</a> components, and <a href="https://developer.android.google.cn/reference/kotlin/android/content/Context.html#startService(android.content.Intent)" target="_blank" rel="noopener">android.content.Context#startService</a> or <a href="https://developer.android.google.cn/reference/kotlin/android/content/Context.html#bindService(android.content.Intent,%20android.content.ServiceConnection,%20kotlin.Int)" target="_blank" rel="noopener">android.content.Context#bindService</a> to communicate with a background <a href="https://developer.android.google.cn/reference/kotlin/android/app/Service.html" target="_blank" rel="noopener">android.app.Service</a> .<br>An Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed.</p></blockquote><p>Intent 名为意图，它是要执行操作的抽象描述，可以在activity、broadcast、service等组件进行请求操作时用来充当消息传递对象（intent可传递基础类型数据或者可序列化的对象数据）此时Intent包含要执行的动作的抽象描述。</p><h2 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h2><p>Intent主要分为两大类：显示Intent和隐式Intent。</p><h3 id="显示Intent"><a href="#显示Intent" class="headerlink" title="显示Intent"></a>显示Intent</h3><p><strong>定义 ：</strong>显示的指定具体类名启动一个组件 一般用于同应用内的组件启动 因为可以方便的知道启动组件的类名</p><p><strong>使用方式：</strong>1、通过Intent构造函数传入要启动类名<br>                     2、直接设置要启动类名（调用setComponent(), setClass(), setClassName()传入组件名）</p><h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p><strong>定义 ：</strong>不知道要启动的组件名，通过匹配其他组件中manifest文件的Intent-filter，启动符合条件的组件，并把Intent中的参数传过去，一般用于启动外部应用的组件</p><p><strong>使用方式：</strong>通过设置action、Category、data等去匹配符合条件的组件（<strong>注意：</strong>如果有多个intent-filter满足条件，那么系统会弹出一个对话框，由用户决定启动哪个组件 ）</p><p><strong><em>假如我们不希望其他应用启动我们的组件，只希望在本应用中使用组件，那么我们就不要在清单中声明，并且将该组件的 exported 属性设置为 false</em></strong></p><h2 id="三、intent工作流程"><a href="#三、intent工作流程" class="headerlink" title="三、intent工作流程"></a>三、intent工作流程</h2><p>以Activity A启动Activity B为例说明：<br>1、首先Activity A调用startActivity()并传入的Intent<br>2、系统会根据该Intent的条件搜索Android系统中所有匹配的组件<br>3、若找到了匹配intent的intent-filters所属的组件（Activity B），则启动该组件，并回调onCreate()方法，同时将Intent传递过去</p><p><img src="https://developer.android.google.cn/images/components/intent-filters_2x.png" srcset="/img/loading.gif" alt="Intent"></p><h2 id="四、构建Intent"><a href="#四、构建Intent" class="headerlink" title="四、构建Intent"></a>四、构建Intent</h2><p>Intent的构建主要是为其设置各种属性包括：<strong>action</strong>、<strong>data</strong>、<strong>type</strong>、<strong>component</strong>、<strong>category</strong>、<strong>extras</strong>、<strong>flags</strong>。其中主要属性是<strong>action</strong>、<strong>data</strong> 。下面我们来详细解析下每个属性的意义和作用。</p><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action是指要执行的动作。它很大程度上决定了category和data中应传入的信息；除了官方定义的我们也可以自己定义action，以便让其他应用程序启动自己的组件。action可以通过setAction来设置或者在Intent构造函数中设置。</p><pre><code>系统提供的常用Action：public static final String ACTION_MAIN = “android.intent.action.MAIN”; //Android 的程序入口public static final String ACTION_VIEW = “android.intent.action.VIEW”; //显示指定数据public static final String ACTION_WEB_SEARCH = “android.intent.action.WEB_SEARCH”;//网页搜索关键字public static final String ACTION_CALL = “android.intent.action.CALL”; //直接呼叫 Data 中所带的号码</code></pre><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data 属性通常是为 Action 属性提供要操作的数据,Data 属性的值是一个 Uri 对象，格式是：schema://host:port/path 。其各个字段含义如下：<br>      * schema 协议 比如“http”、“https”、“tel”…<br>      * host 主机名如“google.com”，如果定义为“*”则表示任意主机名<br>      * port 端口号<br>      * path 路径</p><p> 可以通过setData设置data 。</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>Type 属性用于指定 Data 所制定的 Uri 对应的MIME 类型。MIME 类型是设定某种扩展名的 文件用一种应用程序来打开的方式类型。常见MIME类型 ： “image/png”、”image/jpeg”</p><p>可以通过setType设置 type。<br><strong><em>但是要注意的是如果您需要同时设置URI和MIME类型，只能调用setDataAndType()方法，而不能分别调用setData()和setType()，因为调用setData()时会首先将setType()中的内容置空，反之亦然。</em></strong></p><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>component是要启动目标组件的名字。对于显式启动，这是不可缺省的，没有指定 ComponentName 属性的 Intent 被称为隐式 Intent。</p><p>可以通过调用setComponent(), setClass(), setClassName()等方法设置或者通过Intent的构造方法设置。</p><h3 id="category"><a href="#category" class="headerlink" title="category"></a>category</h3><p>category是要执行动作的目标所具有的特质或行为归类（为 Action 增加额外的附加类别信息）<br>几个常见的category如下：</p><pre><code>Intent.CATEGORY_DEFAULT（android.intent.category.DEFAULT）// 默认的categoryIntent.CATEGORY_PREFERENCE（android.intent.category.PREFERENCE） //表示该目标Activity是一个首选项界面；Intent.CATEGORY_BROWSABLE（android.intent.category.BROWSABLE）//指定了此category后，在网页上点击图片或链接时，系统会考虑将此目标Activity列入可选列表，供用户选择以打开图片或链接。</code></pre><p>可以通过setCategory来进行设置。</p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><p>flags为intent添加元数据（meta-data），flag可以指导系统以何种方式启动一个activity、是否将启动的activity放在该应用的任务栈中，等等。<br>常用flags：</p><pre><code>FLAG_ACTIVITY_NEW_TASK：设置这个标记位的话，是为 Activity 指定 “singleTask” 启动模式，它的作用和在清单文件中指定该启动模式的效果一样。FLAG_ACTIVITY_SINGLE_TOP：设置这个标记位的话，是为 Activity 指定 “singleTop” 启动模式，它的作用和在清单文件中指定该启动模式的效果一样。FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的 Activity ，在它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈。FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的 Activity 不会出现在历史 Activity 的列表中。它等同于在清单文件中指定 Activity 的属性 android:excludeFromRecents=“true”</code></pre><p>可以通过setFlags来进行设置。</p><h3 id="extras"><a href="#extras" class="headerlink" title="extras"></a>extras</h3><p>extras用于添加一些附加信息，它的属性值是一个 Bundle 对象，通过键值对的形式存储数据。</p><p>需要注意的是在使用putExtras方法设置Bundle对象之后，系统进行的不是引用操作，而是复制操作，所以如果设置完之后再更改bundle实例中的数据，将不会影响Intent内部的附加信息。</p><p>可以通过putExtras来进行设置。</p><h3 id="Intent属性小结"><a href="#Intent属性小结" class="headerlink" title="Intent属性小结"></a>Intent属性小结</h3><p>Component name, action, data, and category代表了intent的属性，通过设置这些参数，系统可以筛选出符合条件的目标组件。但是，Extras、Flags这两个参数系统不会用来筛选目标组件。</p><h2 id="五、IntentFilter匹配规则"><a href="#五、IntentFilter匹配规则" class="headerlink" title="五、IntentFilter匹配规则"></a>五、IntentFilter匹配规则</h2><p>IntentFilter是manifest文件中组件内部的一个标签，该标签描述了组件具备什么特性，如果您未配置intent-filters，那个该组件只能被显式启动。我们在mainfest中设置的ntent-filters如果可以匹配某个隐式Intent那么该组件就可以被启动。IntentFilter在做匹配时主要是根据action, type, category这三个属性且匹配优先级是：action&gt;data&gt;category</p><h4 id="action匹配规则："><a href="#action匹配规则：" class="headerlink" title="action匹配规则："></a>action匹配规则：</h4><p>如果Intent指明定了action，则目标组件的IntentFilter的action列表中就必须包含有这个action，否则不能匹配。一个Intent Filter中可声明多个action，此时Intent中的action与其中的任一个action在字符串形式上完全相同即可匹配成功。</p><p>特殊情况：<br>如果filter中没有设置任何action 那么所有的intent匹配都会失败<br>如果action只和category组合使用（隐式调用的条件），intent中不指定action，那么无法启动目标组件<br>如果action和category、data组合使用，intent中不指定action但是filter中至少存在一个action 那么是可以匹配成功的</p><h4 id="category的匹配规则："><a href="#category的匹配规则：" class="headerlink" title="category的匹配规则："></a>category的匹配规则：</h4><p>Intent-filter可定义零到多个category标签intent中的定义的每一个category都需要匹配上intent-filter中的category标签，反之不成立（intent-filter中的category标签可能比intent中的定义的category多）。所以无论intent-filter中是否定义了category标签，未添加category的intent总能匹配上该intent-filter。</p><p>注意：<br>通过startActivity()或startActivityForResult()方法隐式启动的intent中，将自动被添加一个CATEGORY_DEFAULT的category，所以若您希望自己的activity能够被隐式启动，则需要在intent-filter中添加一个android.intent.category.DEFAULT的category标签。</p><h4 id="data匹配规则："><a href="#data匹配规则：" class="headerlink" title="data匹配规则："></a>data匹配规则：</h4><p>intent filter可定义零到多个data标签每个data标签都能设置mimeType和URI 结构，其中URI可分成四部分：scheme, host, port 和 path。但是是有一个线性依赖：若scheme 未指定，则host被忽略；若host未指定，则port被忽略；<br>若scheme和host均未指定，则path被忽略；</p><p>在intent中添加的data只需要匹配一部分intent-filter中的data：</p><ul><li>若filter只定义了scheme，则intent的data定义的URI中只要包含了相同的scheme，就能匹配；</li><li>若filter只定义了scheme和host，则intent的data定义的URI中只要包含了相同的scheme和host，就能匹配；</li><li>若filter只定义了scheme、host和port，则intent的data定义的URI中只要包含了相同的scheme、host和port，就能匹配</li></ul><h2 id="六、Intent源码解析"><a href="#六、Intent源码解析" class="headerlink" title="六、Intent源码解析"></a>六、Intent源码解析</h2><p>Intent的源码大约1W行其中对我们有用打大概有以下几类：</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code>public Intent() {}public Intent(String action) {    setAction(action);}public Intent(String action, Uri uri) {    setAction(action);    mData = uri;}</code></pre><p>Intent提供了8中构造函数供我们使用。</p><h4 id="属性的set和get方法"><a href="#属性的set和get方法" class="headerlink" title="属性的set和get方法"></a>属性的set和get方法</h4><pre><code>public @Nullable Uri getData() {    return mData;}public @Nullable String getType() {    return mType;}public @NonNull Intent setData(@Nullable Uri data) {    mData = data;    mType = null;    return this;}public @NonNull Intent setType(@Nullable String type) {    mData = null;    mType = type;    return this;}public @NonNull Intent setDataAndType(@Nullable Uri data, @Nullable String type) {    mData = data;    mType = type;    return this;}//...</code></pre><p>此处我们看到下setData/Type，单独调用都会把对方置空，所以如果你想设置data和type需要调用setDataAndType，而不能先调用其中一个然后再调用另一个。<br>此外还有putExtra等相关函数这里就不做分析了，有兴趣的可自行查看源码。<br>最后看一个平时我们并不常用的函数toUri：</p><pre><code>public String toUri(@UriFlags int flags) {    StringBuilder uri = new StringBuilder(128);    if ((flags&amp;URI_ANDROID_APP_SCHEME) != 0) {        if (mPackage == null) {            throw new IllegalArgumentException(                    &quot;Intent must include an explicit package name to build an android-app: &quot;                    + this);        }        uri.append(&quot;android-app://&quot;);        uri.append(mPackage);        String scheme = null;        if (mData != null) {            scheme = mData.getScheme();            if (scheme != null) {                uri.append(&#39;/&#39;);                uri.append(scheme);                String authority = mData.getEncodedAuthority();                if (authority != null) {                    uri.append(&#39;/&#39;);                    uri.append(authority);                    String path = mData.getEncodedPath();                    if (path != null) {                        uri.append(path);                    }                    String queryParams = mData.getEncodedQuery();                    if (queryParams != null) {                        uri.append(&#39;?&#39;);                        uri.append(queryParams);                    }                    String fragment = mData.getEncodedFragment();                    if (fragment != null) {                        uri.append(&#39;#&#39;);                        uri.append(fragment);                    }                }            }        }        toUriFragment(uri, null, scheme == null ? Intent.ACTION_MAIN : Intent.ACTION_VIEW,                mPackage, flags);        return uri.toString();    }    String scheme = null;    if (mData != null) {        String data = mData.toString();        if ((flags&amp;URI_INTENT_SCHEME) != 0) {            final int N = data.length();            for (int i=0; i&lt;N; i++) {                char c = data.charAt(i);                if ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)                        || c == &#39;.&#39; || c == &#39;-&#39;) {                    continue;                }                if (c == &#39;:&#39; &amp;&amp; i &gt; 0) {                    // Valid scheme.                    scheme = data.substring(0, i);                    uri.append(&quot;intent:&quot;);                    data = data.substring(i+1);                    break;                }                // No scheme.                break;            }        }        uri.append(data);    } else if ((flags&amp;URI_INTENT_SCHEME) != 0) {        uri.append(&quot;intent:&quot;);    }    toUriFragment(uri, scheme, Intent.ACTION_VIEW, null, flags);    return uri.toString();}</code></pre><p>它的作用是把一个Intent转化为一个Uri，转化后的Uri包含原先Intent的action, categories, type, flags, package, component, and extras等属性。同时Intent还提供了getIntent方法把Uri转换回Intent。<br>Intent转换Uri过程就是将Intent的属性值读取出来进行拼接然后序列化。不过需要注意的是它没有关于 Bundle 的参数传递，所以转换过程会把设置的bundle数据丢失。<br>利用该函数我们可以不必在调用startActivity前去new Intent而是通过getIntent把一个Uri转化为Intent然后再startActivity，这样做的好处是startActivity中传入的intent变为”可控”的。</p><h2 id="七、相关问题"><a href="#七、相关问题" class="headerlink" title="七、相关问题"></a>七、相关问题</h2><h3 id="path、pathPrefix、pathPattern-之间的区别"><a href="#path、pathPrefix、pathPattern-之间的区别" class="headerlink" title="path、pathPrefix、pathPattern 之间的区别"></a>path、pathPrefix、pathPattern 之间的区别</h3><p>path 用来匹配完整的路径，如：<a href="http://example.com/blog/abc.html，这里将" target="_blank" rel="noopener">http://example.com/blog/abc.html，这里将</a> path 设置为 /blog/abc.html 才能够进行匹配；<br>pathPrefix 用来匹配路径的开头部分，拿上来的 Uri 来说，这里将 pathPrefix 设置为 /blog 就能进行匹配了；<br>pathPattern 用表达式来匹配整个路径，这里需要说下匹配符号与转义。<br>匹配符号：<br>“” 用来匹配0次或更多，如：“a” 可以匹配“a”、“aa”、“aaa”…<br>“.” 用来匹配任意字符，如：“.” 可以匹配“a”、“b”，“c”…<br>因此 “.<em>” 就是用来匹配任意字符0次或更多，如：“.</em>html” 可以匹配 “abchtml”、“chtml”，“html”，“sdf.html”…</p><h3 id="Intent传递数据的大小限制"><a href="#Intent传递数据的大小限制" class="headerlink" title="Intent传递数据的大小限制"></a>Intent传递数据的大小限制</h3><p>intent传递过大的数据会导致TransactionTooLargeException，其本质原因是intent使用binder进行数据传递。在过程中Intent 中的数据，会作为 Parcel 被存储在 Binder 的事务缓冲区(Binder transaction buffer)中的对象进行传输。但是Binder 的事务缓冲区大小为1M，并且该缓冲区是进程共享的。</p><p>解决方法：<br>1、避免传递过大数据<br>2、使用 EventBus 的粘性事件来解决</p><h3 id="查询是否有Activity可以匹配我们指定Intent的组件"><a href="#查询是否有Activity可以匹配我们指定Intent的组件" class="headerlink" title="查询是否有Activity可以匹配我们指定Intent的组件"></a>查询是否有Activity可以匹配我们指定Intent的组件</h3><p>在启动Activity时传入intent找不到符合条件的Activity那么程序将会崩溃，所以我们每次startActivity时最好查询下是否有Activity可以匹配我们指定Intent的组件，可以使用以下方法：</p><ul><li>PackageManager的resolveActivity或者Intent的resolveActivity方法会获得最适合Intent的一个Activity</li><li>调用PackageManager的queryIntentActivities会返回所有成功匹配Intent的Activity</li></ul><h3 id="android-intent-action-MAIN-与android-intent-category-LAUNCHER、android-intent-category-HOME的区别"><a href="#android-intent-action-MAIN-与android-intent-category-LAUNCHER、android-intent-category-HOME的区别" class="headerlink" title="android.intent.action.MAIN 与android.intent.category.LAUNCHER、android.intent.category.HOME的区别"></a>android.intent.action.MAIN 与android.intent.category.LAUNCHER、android.intent.category.HOME的区别</h3><h4 id="android-intent-action-MAIN"><a href="#android-intent-action-MAIN" class="headerlink" title="android.intent.action.MAIN"></a>android.intent.action.MAIN</h4><p>应用的入口即最先启动的组件</p><h4 id="android-intent-category-LAUNCHER"><a href="#android-intent-category-LAUNCHER" class="headerlink" title="android.intent.category.LAUNCHER"></a>android.intent.category.LAUNCHER</h4><p>决定是否在桌面显示图标</p><h4 id="android-intent-category-HOME"><a href="#android-intent-category-HOME" class="headerlink" title="android.intent.category.HOME"></a>android.intent.category.HOME</h4><p>按住“HOME”键，该程序显示在HOME列表里</p><h3 id="有多个匹配组件时如何设置每次都弹窗"><a href="#有多个匹配组件时如何设置每次都弹窗" class="headerlink" title="有多个匹配组件时如何设置每次都弹窗"></a>有多个匹配组件时如何设置每次都弹窗</h3><p>当有多个应用可以响应我们的隐式 Activity 时，系统会弹出一个选择框，让用户选择需要打开的应用，用户也可以选择记住要自己打开的应用，这样下次就不会再弹出选择框。那么假如我希望每次都弹窗，不让用户记住呢？我们可以使用 createChooser() 创建 Intent</p><p> 参考文章：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;mid=2247484812&amp;idx=1&amp;sn=14886c84cff5b1bfea5b210a7e261672&amp;chksm=97851cada0f295bbfc1b4bd970ca45988105a8e1e6ac7a498b99521b8261cfb06386b0f3d3dd&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;mid=2247484812&amp;idx=1&amp;sn=14886c84cff5b1bfea5b210a7e261672&amp;chksm=97851cada0f295bbfc1b4bd970ca45988105a8e1e6ac7a498b99521b8261cfb06386b0f3d3dd&amp;scene=38#wechat_redirect</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650235926&amp;idx=1&amp;sn=58d03be2956944647df6a9719c90d13b&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650235926&amp;idx=1&amp;sn=58d03be2956944647df6a9719c90d13b&amp;scene=38#wechat_redirect</a></li><li><a href="https://blog.csdn.net/mynameishuangshuai/article/details/51673273" target="_blank" rel="noopener">https://blog.csdn.net/mynameishuangshuai/article/details/51673273</a></li><li><a href="https://juejin.im/post/5db11e8051882564a061837b" target="_blank" rel="noopener">Android 基础知识5：Intent 和 Intent 过滤器 - 掘金</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Intent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Context知识详解</title>
    <link href="/2019/10/22/%20ContextDK/"/>
    <url>/2019/10/22/%20ContextDK/</url>
    
    <content type="html"><![CDATA[<p>Context相关知识以及源码解析</p><a id="more"></a><h1 id="Context知识详解"><a href="#Context知识详解" class="headerlink" title="Context知识详解"></a>Context知识详解</h1><p>建议配合context知识架构图食用。</p><h2 id="一、什么是Context"><a href="#一、什么是Context" class="headerlink" title="一、什么是Context"></a>一、什么是Context</h2><p>贴一个官方解释：</p><blockquote><p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p></blockquote><p>  上面的意思：context是一个应用程序环境的全局信息的接口。这是一个抽象类，其实现由Android系统提供。它允许访问特定于应用程序的资源和类，以及对应用程序级操作（如启动活动，广播和接收意图等）的调用。</p><p>这个解释可能听起来比较抽象，我的理解是一些Android组件（如activity、service）的运行需要一定的“环境”，就好像我们工作一般都是在办公室 ，休息则是在家里，我们都是处在一定的“环境”下去工作、学习、休息的，Android组件也是类似，它们不能脱离“环境”去运转，而这个“环境”在Android中就是context。</p><h2 id="二、Context子类以及其继承关系"><a href="#二、Context子类以及其继承关系" class="headerlink" title="二、Context子类以及其继承关系"></a>二、Context子类以及其继承关系</h2><p>先贴个图<br><img src="https://img2018.cnblogs.com/blog/1902145/201912/1902145-20191218185657055-2012607942.jpg" srcset="/img/loading.gif" alt="context"></p><p>由图我们可以看出context有两个子类ContextImpl和ContextWrapper。</p><h3 id="ContextWrapper"><a href="#ContextWrapper" class="headerlink" title="ContextWrapper"></a>ContextWrapper</h3><p>我们先来看下ContextWrapper。</p><pre><code>*/**** * Proxying implementation of Context that simply delegates all of its calls to** * another Context.  Can be subclassed to modify behavior without changing** * the original Context.** */*public class ContextWrapper extends Context {    Context mBase;    public ContextWrapper(Context base) {        mBase = base;    }    */****     * Set the base context for this ContextWrapper.  All calls will then be**     * delegated to the base context.  Throws**     * IllegalStateException if a base context has already been set.**     * **     ****@param***base The new base context for this wrapper.**     */*protected void attachBaseContext(Context base) {        if (mBase != null) {            throw new IllegalStateException(“Base context already set”);        }        mBase = base;    }    */****     ****@return***the base context as set by the constructor or setBaseContext**     */*public Context getBaseContext() {        return mBase;    }    @Override    public AssetManager getAssets() {        return mBase.getAssets();    }    @Override    public Resources getResources() {        return mBase.getResources();    }    @Override    public PackageManager getPackageManager() {        return mBase.getPackageManager();    }    @Override    public ContentResolver getContentResolver() {        return mBase.getContentResolver();    }    @Override    public Looper getMainLooper() {        return mBase.getMainLooper();    }    @Override    public Context getApplicationContext() {        return mBase.getApplicationContext();    }    @Override    public void setTheme(int resid) {        mBase.setTheme(resid);    }    */*****@hide****/*@Override    public int getThemeResId() {        return mBase.getThemeResId();    }    @Override    public Resources.Theme getTheme() {        return mBase.getTheme();    }    @Override    public void startActivity(Intent intent) {        mBase.startActivity(intent);    }    @Override    public void sendBroadcast(Intent intent) {        mBase.sendBroadcast(intent);    }//...}</code></pre><p>该类直接继承自Context，并实现了Context定义的抽象方法。不过我们看源码发现其实它并未实质的去实现Context定义的操作只是通过mBase调用对应的方法去执行。这个mBase也是一个Context类型的变量，它的赋值是通过attachBaseContext赋值的。我们还知道service和application都是ContextWrapper子类，所以service和application都是Context。</p><pre><code>public abstract class Service extends ContextWrapper implements ComponentCallbacks2 {    //...}public class Application extends ContextWrapper implements ComponentCallbacks2 {    //...}</code></pre><p>ContextWrapper还有一个子类ContextThemeWrapper。</p><pre><code>public class ContextThemeWrapper extends ContextWrapper {    private int mThemeResource;    private Resources.Theme mTheme;    private LayoutInflater mInflater;    public ContextThemeWrapper(Context base, @StyleRes int themeResId) {        super(base);        mThemeResource = themeResId;    }    public ContextThemeWrapper(Context base, Resources.Theme theme) {        super(base);        mTheme = theme;    }    @Override    public Resources getResources() {        return getResourcesInternal();    }    private Resources getResourcesInternal() {        if (mResources == null) {            if (mOverrideConfiguration == null) {                mResources = super.getResources();            } else if (Build.VERSION.SDK_INT &gt;= 17) {                final Context resContext = createConfigurationContext(mOverrideConfiguration);                mResources = resContext.getResources();            }        }        return mResources;    }    @Override    public void setTheme(int resid) {        if (mThemeResource != resid) {            mThemeResource = resid;            initializeTheme();        }    }    public int getThemeResId() {        return mThemeResource;    }    @Override    public Resources.Theme getTheme() {        if (mTheme != null) {            return mTheme;        }        if (mThemeResource == 0) {            mThemeResource = R.style.Theme_AppCompat_Light;        }        initializeTheme();        return mTheme;    }    private void initializeTheme() {        final boolean first = mTheme == null;        if (first) {            mTheme = getResources().newTheme();            Resources.Theme theme = getBaseContext().getTheme();            if (theme != null) {                mTheme.setTo(theme);            }        }        onApplyThemeResource(mTheme, mThemeResource, first);    }//...}</code></pre><p>可以看出ContextThemeWrapper主要是包含了主题Theme相关的接口，即android:theme属性指定的。而activity则是继承自ContextThemeWrapper。</p><pre><code>public class Activity extends ContextThemeWrapper        implements LayoutInflater.Factory2,        Window.Callback, KeyEvent.Callback,        OnCreateContextMenuListener, ComponentCallbacks2,        Window.OnWindowDismissedCallback {    //...}</code></pre><h3 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h3><p>由ContextWrapper源码我们知道实际上它并没有实现Context定义的相关操作。那么Context的真实实现类到底是谁呢 答案就是ContextImpl。它是Android系统提供的唯一的Context真实 实现类。</p><pre><code>class ContextImpl extends Context {    @Override    public void startActivity(Intent intent) {        warnIfCallingFromSystemProcess();        startActivity(intent, null);    }    @Override    public void sendBroadcast(Intent intent) {        warnIfCallingFromSystemProcess();        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());        try {            intent.prepareToLeaveProcess(this);            ActivityManager.getService().broadcastIntent(                    mMainThread.getApplicationThread(), intent, resolvedType, null,                    Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,                    getUserId());        } catch (RemoteException e) {            throw e.rethrowFromSystemServer();        }    }    @Override    public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {        return registerReceiver(receiver, filter, null, null);    }    @Override    public ComponentName startService(Intent service) {        warnIfCallingFromSystemProcess();        return startServiceCommon(service, false, mUser);    }    //...}</code></pre><p>由源码看出ContextImpl确是是真实的实现了Context。</p><h2 id="三、一个应用Context个数"><a href="#三、一个应用Context个数" class="headerlink" title="三、一个应用Context个数"></a>三、一个应用Context个数</h2><p>通过上面Context子类继承关系的分析，一个应用Context个数显而易见。<br>APP Context总数 = Application(1) + Activity个数+ Service个数;</p><h2 id="四、不同的Context之间差异"><a href="#四、不同的Context之间差异" class="headerlink" title="四、不同的Context之间差异"></a>四、不同的Context之间差异</h2><p>我们知道Application的生命周期跟应用的生命周期是相同的，所以Application的Context生命周期与应用程序完全相同。同理<br>Activity或者Service的Context与他们各自类生命周期相同。</p><p>由此可知Context使用不当会引起内存泄漏，我们在使用Context时必须要注意其生命周期。</p><ul><li><p>尽量使用 Application 的 Context</p></li><li><p>不要让生命周期长于 Activity 的对象持有其的引用</p></li><li><p>尽量不要在 Activity 中使用非静态内部类，因为非静态内部类会隐式持有外部类示例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p></li></ul><h2 id="五、不同Context的应用场景"><a href="#五、不同Context的应用场景" class="headerlink" title="五、不同Context的应用场景"></a>五、不同Context的应用场景</h2><p><img src="https://img-blog.csdn.net/20150104183450879" srcset="/img/loading.gif" alt="Context应用场景"></p><blockquote><p>大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：<br>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。<br>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。<br>数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）<br>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p></blockquote><p>以上参考<a href="https://blog.csdn.net/lmj623565791/article/details/40481055" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/40481055</a></p><p>由表格我们可以归纳出这样一个结论：操作涉及UI的应该使用Activity做为Context，不涉及UI的Service,Activity,Application等实例都可以。</p><h2 id="六、不同Context实例化过程"><a href="#六、不同Context实例化过程" class="headerlink" title="六、不同Context实例化过程"></a>六、不同Context实例化过程</h2><h3 id="Activity-中Context实例化过程"><a href="#Activity-中Context实例化过程" class="headerlink" title="Activity 中Context实例化过程"></a>Activity 中Context实例化过程</h3><p>在Activity的启动过程中，activity的创建是在ActivityThread.<br>performLaunchActivity方法中完成的。</p><pre><code>//ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r,Intent customIntent){        //...        ContextImpl appContext=createBaseContextForActivity(r);//1、创建ContextImpl实例        Activity activity=null;        try{        java.lang.ClassLoader cl=appContext.getClassLoader();        //...        activity=mInstrumentation.newActivity(        cl,component.getClassName(),r.intent);//2、创建Activity        StrictMode.incrementExpectedActivityCount(activity.getClass());        r.intent.setExtrasClassLoader(cl);        r.intent.prepareToEnterProcess();        if(r.state!=null){        r.state.setClassLoader(cl);        }        }catch(Exception e){        if(!mInstrumentation.onException(activity,e)){        throw new RuntimeException(        &quot;Unable to instantiate activity &quot;+component        +&quot;: &quot;+e.toString(),e);        }        }        try{        Application app=r.packageInfo.makeApplication(false,mInstrumentation);        if(activity!=null){        appContext.setOuterContext(activity);//3、调用setOuterContext        activity.attach(appContext,this,getInstrumentation(),r.token,        r.ident,app,r.intent,r.activityInfo,title,r.parent,        r.embeddedID,r.lastNonConfigurationInstances,config,        r.referrer,r.voiceInteractor,window,r.configCallback);//4、调用attach        }       //...    }</code></pre><p>首先通过createBaseContextForActivity创建ContextImpl实例，那我们看下具体是如何创建的</p><pre><code>private ContextImpl createBaseContextForActivity(ActivityClientRecord r) {    final int displayId;    try {        displayId = ActivityManager.getService().getActivityDisplayId(r.token);    } catch (RemoteException e) {        throw e.rethrowFromSystemServer();    }    ContextImpl appContext = ContextImpl.createActivityContext(            this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);//...    return appContext;}</code></pre><p>可以看出是调用createActivityContext，那来看下createActivityContext</p><pre><code>static ContextImpl createActivityContext(ActivityThread mainThread,        LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, int displayId,        Configuration overrideConfiguration) {//...ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,        activityToken, null, 0, classLoader);//...context.setResources(resourcesManager.createBaseActivityResources(activityToken,        packageInfo.getResDir(),        splitDirs,        packageInfo.getOverlayDirs(),        packageInfo.getApplicationInfo().sharedLibraryFiles,        displayId,        overrideConfiguration,        compatInfo,        classLoader));context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,        context.getResources());return context;}</code></pre><p>可以看到是调用了ContextImpl得一个构造函数创建的ContextImpl实例然后还给该实例设置了setResources，至此ContextImpl创建完成。但是我们注意到在创建了ContextImpl实例（appContext）之后又调用了setOuterContext<br>并把当前activity传入，这又是为什么呢？ 看下源码</p><pre><code>private Context mOuterContext;final void setOuterContext(Context context) {    mOuterContext = context;}</code></pre><p>setOuterContext只是简单的把传入的activity赋值给了mOuterContext，这是ContextImpl类中定义的一个变量。通过这个操作ContextImpl就可以持有activity的引用。<br>setOuterContext之后又调用了activity.attach并把appContext传入。</p><pre><code>final void attach(Context context, ActivityThread aThread,        Instrumentation instr, IBinder token, int ident,        Application application, Intent intent, ActivityInfo info,        CharSequence title, Activity parent, String id,        NonConfigurationInstances lastNonConfigurationInstances,        Configuration config, String referrer, IVoiceInteractor voiceInteractor,        Window window, ActivityConfigCallback activityConfigCallback) {    attachBaseContext(context);//...}</code></pre><pre><code>//Activity.javaprotected void attachBaseContext(Context newBase) {    super.attachBaseContext(newBase);    newBase.setAutofillClient(this);}</code></pre><p>Activity的attach我们只关注跟context有关的 那就是调用attachBaseContext，在这个函数内部调用了super.attachBaseContext。我们知道Activity继承自 ContextThemeWrapper， ContextThemeWrapper<br>继承自 ContextWrapper，所以最终会调用ContextWrapper.attachBaseContext，到这里，ContextWrapper类就可以将它的功能交给ContextImpl类来具体实现。</p><pre><code>//ContextWrapper.javaprotected void attachBaseContext(Context base) {    if (mBase != null) {        throw new IllegalStateException(&quot;Base context already set&quot;);    }    mBase = base;}</code></pre><h3 id="Service中Context实例化过程"><a href="#Service中Context实例化过程" class="headerlink" title="Service中Context实例化过程"></a>Service中Context实例化过程</h3><pre><code>private void handleCreateService(CreateServiceData data){        //...        Service service=null;        try{        java.lang.ClassLoader cl=packageInfo.getClassLoader();        service=(Service)cl.loadClass(data.info.name).newInstance();//1、创建service        }catch(Exception e){        if(!mInstrumentation.onException(service,e)){        throw new RuntimeException(        &quot;Unable to instantiate service &quot;+data.info.name        +&quot;: &quot;+e.toString(),e);        }        }        try{        if(localLOGV)Slog.v(TAG,&quot;Creating service &quot;+data.info.name);        ContextImpl context=ContextImpl.createAppContext(this,packageInfo);//2、创建ContextImpl实例        context.setOuterContext(service);//3、设置OuterContext        Application app=packageInfo.makeApplication(false,mInstrumentation);        service.attach(context,this,data.info.name,data.token,app,        ActivityManager.getService()); //4、调用attach        service.onCreate();        mServices.put(data.token,service);        try{        ActivityManager.getService().serviceDoneExecuting(        data.token,SERVICE_DONE_EXECUTING_ANON,0,0);        }catch(RemoteException e){        throw e.rethrowFromSystemServer();        }        }catch(Exception e){        if(!mInstrumentation.onException(service,e)){        throw new RuntimeException(        &quot;Unable to create service &quot;+data.info.name        +&quot;: &quot;+e.toString(),e);        }        }     }</code></pre><p>我们看到Service中Context实例的创建流程跟Activity基本是一样的，首先创建Service实例然后创建ContextImpl实例，之后调用setOuterContext最后是attach。<br>Service中ContextImpl实例是通过函数createAppContext创建的，其内部则是通过ContextImpl的构造函数来创建实例。</p><pre><code>static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {    if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);    ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,            null);    context.setResources(packageInfo.getResources());    return context;}</code></pre><p>setOuterContext操作跟Activity是一样的都是把引用赋值给mOuterContext。<br>最后就是attch了，下面是service的attach，可以看到它也是调用attachBaseContext，下面的流程跟Activity是一样的最终都是ContextWrapper类将它的功能交给ContextImpl类来具体实现。</p><pre><code>public final void attach(        Context context,        ActivityThread thread, String className, IBinder token,        Application application, Object activityManager) {    attachBaseContext(context);//调用attachBaseContext    mThread = thread;           // NOTE:  unused - remove?    mClassName = className;    mToken = token;    mApplication = application;    mActivityManager = (IActivityManager)activityManager;    mStartCompatibility = getApplicationInfo().targetSdkVersion            &lt; Build.VERSION_CODES.ECLAIR;}</code></pre><h3 id="Application中的Context的实例化过程"><a href="#Application中的Context的实例化过程" class="headerlink" title="Application中的Context的实例化过程"></a>Application中的Context的实例化过程</h3><p>Application 的创建是在LoadedApk.makeApplication中。</p><pre><code>//LoadedApk.Javapublic Application makeApplication(boolean forceDefaultAppClass,        Instrumentation instrumentation) {    if (mApplication != null) {        return mApplication;    }//...Application app = null;try {            java.lang.ClassLoader cl = getClassLoader();            if (!mPackageName.equals(&quot;android&quot;)) {                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,                        &quot;initializeJavaContextClassLoader&quot;);                initializeJavaContextClassLoader();                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);            }            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);//1、创建ContextImpl实例            app = mActivityThread.mInstrumentation.newApplication(                    cl, appClass, appContext);//2、创建application            appContext.setOuterContext(app);//3、设置mOuterContext        } catch (Exception e) {            if (!mActivityThread.mInstrumentation.onException(app, e)) {                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);                throw new RuntimeException(                    &quot;Unable to instantiate application &quot; + appClass                    + &quot;: &quot; + e.toString(), e);            }        }        mActivityThread.mAllApplications.add(app);        mApplication = app;//...}</code></pre><p>可以看到Application中是先创建了ContextImpl实例然后创建Application实例最后调用了setOuterContext。看上去跟Service和Activity相比缺少了attach，而我们知道attach是ContextWrapper类将它的功能交给ContextImpl类来具体实现的过程，Application缺少attach那它是如何实现ContextWrapper的代理过程的呢？ 其实Application是有attach的 它在newApplication创建Application的过程中调用的。</p><pre><code>public Application newApplication(ClassLoader cl, String className, Context context)        throws InstantiationException, IllegalAccessException,         ClassNotFoundException {    return newApplication(cl.loadClass(className), context);} static public Application newApplication(Class&lt;?&gt; clazz, Context context)            throws InstantiationException, IllegalAccessException,             ClassNotFoundException {        Application app = (Application)clazz.newInstance();        app.attach(context);//调用application的attach方法        return app;    }final void attach(Context context) {    attachBaseContext(context);  //调用attachBaseContext    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;}</code></pre><p>嗯，这样看application和Service还有Activity的流程基本上是一致的。</p><p>至此Application、Service、Activity中context的实例化过程都已分析完了。</p><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="无侵入式获取全局Context"><a href="#无侵入式获取全局Context" class="headerlink" title="无侵入式获取全局Context"></a>无侵入式获取全局Context</h3><p>使用一个ContentProvider，ContentProvider的onCreate()方法调用时，调用getContext()即可获取到Context，再静态变量保存，后续直接获取即可。</p><pre><code>public class AppContextProvider extends ContentProvider {    static Context mContext;    @Override    public boolean onCreate() {        //mContext保存为静态变量        mContext = getContext();        return false;    }    //...}&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        package=&quot;com.app.contextprovider&quot;&gt;    &lt;application&gt;        &lt;!-- 全局Context提供者 --&gt;        &lt;provider                android:name=&quot;.AppContextProvider&quot;                android:authorities=&quot;${applicationId}.contextprovider&quot;                android:exported=&quot;false&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="getApplication和getApplicationContext的区别"><a href="#getApplication和getApplicationContext的区别" class="headerlink" title="getApplication和getApplicationContext的区别"></a>getApplication和getApplicationContext的区别</h3><p>首先来看getApplication方法,它只有在Activity和Service中有实现</p><pre><code>Activity/** Return the application that owns this activity. */public final Application getApplication() {    return mApplication;}Service/** Return the application that owns this service. */public final Application getApplication() {    return mApplication;}</code></pre><p>Activity和Service中getApplication返回的是一个application对象。</p><p>getApplicationContext是ContextWrapper提供的方法，由源码可知它调用的是mBase的getApplicationContext()。此处的mBase实际是一个ContextImpl，所以我们看下ContextImpl的getApplicationContext()，可以看到返回的是mPackageInfo.getApplication()（此处的mPackageInfo包含当前应用的包信息、比如包名、应用的安装目录等信息，一般不为空）。</p><pre><code>//ContextWrapperpublic Context getApplicationContext() {    return mBase.getApplicationContext();}//ContextImplpublic Context getApplicationContext() {    return (mPackageInfo != null) ?            mPackageInfo.getApplication() : mMainThread.getApplication();}</code></pre><p>我们知道一个应用只有一个Application所以getApplication和getApplicationContext 实际上都是返回当前应用的Application，它们是同一个对象。这两个函数的区别就是getApplication只能在Activity和Service中调用，而getApplicationContext 的使用范围则要大一些，比如在广播中想要获取全局的Context则需要使用getApplicationContext 而不是getApplication。</p><p><strong>以上就是Context相关知识点的整理解析。</strong></p><blockquote><p>本文所有源码基于Android-8.0.0_r1</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Context知识架构图</title>
    <link href="/2019/10/21/Context/"/>
    <url>/2019/10/21/Context/</url>
    
    <content type="html"><![CDATA[<p>一份Context知识框架图 帮助我们清晰直观的了解Context</p><a id="more"></a><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>  框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="/img/Context.png" srcset="/img/loading.gif" alt="image"></p><p><img src="https://wx3.sinaimg.cn/mw690/006pFTMZly1ga0zn0ebnxj31g30u0n8f.jpg" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Context</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment知识架构图</title>
    <link href="/2019/10/16/Fragment/"/>
    <url>/2019/10/16/Fragment/</url>
    
    <content type="html"><![CDATA[<p>一份Fragment知识框架图 帮助我们清晰直观的了解Fragment</p><a id="more"></a><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><p>  框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="https://wx3.sinaimg.cn/mw690/006pFTMZly1ga0zwiy92yj30u01jkb2a.jpg" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Fragment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent知识架构图</title>
    <link href="/2019/10/10/Intent/"/>
    <url>/2019/10/10/Intent/</url>
    
    <content type="html"><![CDATA[<p>一份Intent知识框架图 帮助我们清晰直观的了解Intent</p><a id="more"></a><h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>  框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="/img/Intent.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Intent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ContentProvider知识架构图</title>
    <link href="/2019/09/29/ContentProvider/"/>
    <url>/2019/09/29/ContentProvider/</url>
    
    <content type="html"><![CDATA[<p>一份ContentProvider知识框架图 帮助我们清晰直观的了解ContentProvider</p><a id="more"></a><h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>   Android四大组件之ContentProvider。框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="/img/Activity.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>ContentProvider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Broadcast知识架构图</title>
    <link href="/2019/09/20/Broadcast/"/>
    <url>/2019/09/20/Broadcast/</url>
    
    <content type="html"><![CDATA[<p>一份Broadcast知识框架图 帮助我们清晰直观的了解Broadcast</p><a id="more"></a><h1 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h1><p>  Android四大组件之Broadcast，框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="/img/Broadcast.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Broadcast</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service知识架构图</title>
    <link href="/2019/09/12/Service/"/>
    <url>/2019/09/12/Service/</url>
    
    <content type="html"><![CDATA[<p>一份Service知识框架图 帮助我们清晰直观的了解Service</p><a id="more"></a><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>   Service 作为Android四大组件之一也是我们经常接触到的组件之一，重要性不言而喻 我们有必要熟悉掌握其涉及的基础知识。因此我抽时间整理了下Service常见知识点形成一个Service知识框架图这样会相对清晰直观些也方便以后随时查阅 尤其是面试前的基础知识准备。</p><p>   当然这个框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><p><img src="/img/Service.png" srcset="/img/loading.gif" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity知识架构图</title>
    <link href="/2019/09/10/Activity/"/>
    <url>/2019/09/10/Activity/</url>
    
    <content type="html"><![CDATA[<p>一份Activity知识框架图 帮助我们清晰直观的了解Activity</p><a id="more"></a><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>   activity 作为Android四大组件之一也是我们经常接触到的组件之一，重要性不言而喻 我们有必要熟悉掌握其涉及的基础知识。因此我抽时间整理了下activity常见知识点形成一个activity知识框架图这样会相对清晰直观些也方便以后随时查阅 尤其是面试前的基础知识准备。</p><p>   当然这个框架图可能并不完整不过我会不断更新的 如果你有想补充或者看到有出错的地方 请及时联系我。</p><!--![image](/img/Activity.png)--><p><img src="https://i.loli.net/2020/02/26/PFmxkhBryfHaOJD.jpg" srcset="/img/loading.gif" alt="bannericon.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Basics</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler三部曲(三)</title>
    <link href="/2019/08/22/Handler(%E4%B8%89)/"/>
    <url>/2019/08/22/Handler(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>导读：通过以上两篇文章相信你已经对Handler有了一个清晰的了解，为了学以致用这篇文章我们就来手写一个简化版的Handler。</p><a id="more"></a><h1 id="Handler三部曲（三）"><a href="#Handler三部曲（三）" class="headerlink" title="Handler三部曲（三）"></a>Handler三部曲（三）</h1><p>先来写Handler类</p><pre><code>public class HandlerLite {    private static final String TAG = &quot;HandlerLite&quot;;    Runnable callback;    private Looper myLooper;    private MessageQueue mQueue;    private Callback mCallback;    /**     * 构造函数     */    public HandlerLite() {        this(null);    }    /**     * @param callback     */    public HandlerLite(Callback callback) {        //获取looper实例        myLooper = Looper.myLooper();        if (myLooper == null) {            throw new RuntimeException(                    &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);        }        mQueue = myLooper.mQueue;        mCallback = callback;    }    /**     * 从message缓存池中获取一个message 推荐用此方法获取message实例或者直接调用Message.obtain()     *     * @return     */    public Message obtainMessage() {        return Message.obtain();    }    public final boolean sendMessage(Message msg) {        return sendMessageDelayed(msg, 0);    }    private boolean sendMessageDelayed(Message msg, long delay) {        if (delay &lt; 0) {            delay = 0;        }        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delay);    }    public final boolean sendMessageAtTime(Message msg, long delay) {        MessageQueue messageQueue = mQueue;        if (messageQueue == null) {            RuntimeException e = new RuntimeException(this + &quot; sendMessageAtTime() called with no mQueue&quot;);            Log.w(&quot;Looper&quot;, e.getMessage(), e);            return false;        }        return enQueueMessage(messageQueue, msg, delay);    }    private boolean enQueueMessage(MessageQueue messageQueue, Message msg, long delay) {        msg.target = this;        return messageQueue.enQueueMessage(msg, delay);    }    public final boolean post(Runnable r) {        return sendMessageDelayed(getPostMessage(r), 0);    }    private static Message getPostMessage(Runnable r) {        Message m = Message.obtain();        m.callback = r;        return m;    }    public final boolean postDelayed(Runnable r, long delayMillis) {        return sendMessageDelayed(getPostMessage(r), delayMillis);    }    public void dispatchMessage(Message msg) {        if (msg.callback != null) {            handleCallback(msg);        } else {            if (mCallback != null) {                if (mCallback.handleMessage(msg)) {                    return;                }            }            handleMessage(msg);        }    }    /**     *     * @param msg     */    public void handleMessage(Message msg) {    }    private static void handleCallback(Message message) {        message.callback.run();    }    /**     * @param message     * @return mesage name if callback is not null return the class name of the     * message callback else return he hexadecimal representation of the     * message &quot;what&quot; field.     */    public String getMessageName(Message message) {        if (message.callback != null) {            return message.callback.getClass().getName();        }        return &quot;0x&quot; + Integer.toHexString(message.what);    }    /**     * handler 回调     */    public interface Callback {        public boolean handleMessage(Message msg);    }}</code></pre><p>HandlerLite对应Handler类，我们提供了两个构造函数，用来初始化myLooper、mQueue、mCallback等filed。<br>之后提供一个obtainMessage方法来获取message。之后提供了sendMessage和post等方法发送消息。之后dispatchMessage方法用来分发处理收到的Message。同时我们也给HandlerLite提供了一个Callback，我们可以通过重写handleMessage或者实现Callback来处理Message。</p><p>总体来看HandlerLite就是一个简化的Handler并没有很大改动。</p><p>下面是Looper类</p><pre><code>public class Looper {    static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();    MessageQueue mQueue;    public Looper() {        mQueue = new MessageQueue();    }    public static void prepare() {        if (sThreadLocal.get() != null) {            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        }        sThreadLocal.set(new Looper());    }    public static void loop() {        final Looper me = myLooper();        if (me == null) {            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        }        final MessageQueue queue = me.mQueue;        for (; ; ) {            Message msg = queue.next();            if (msg == null) {                return;            }            msg.target.dispatchMessage(msg);        }    }    public static Looper myLooper() {        return sThreadLocal.get();    }    public void quit() {        mQueue.quit(false);    }    public void quitSafely() {        mQueue.quit(true);    }}</code></pre><p>可以看出Looper类很简短，我们重点关注loop和prepare函数即可。prepare函数就是new一个新的Looper并保存在当前线程的ThreadLocal中，这样就保证了每个Thread有且仅有一个Looper。而loop是让整个Handler消息机制运转的关键，它会不断的从MessageQueue中取出消息并通过Message持有的Handler进行分发。</p><p>接下来是Message类</p><pre><code>public class Message {    public int what;    public int arg1;    public int arg2;    public Object obj;    //    public long when;    public int flags;    HandlerLite target;    private static final Object sPoolSync = new Object();    private static Message sPool;    Message next;    private static int sPoolSize = 0;    static final int FLAG_IN_USE = 1 &lt;&lt; 0;    Runnable callback;    private static final int MAX_POOL_SIZE = 50;    private static boolean gCheckRecycle = true;    public Message() {    }    public static Message obtain(){        synchronized (sPoolSync) {            if (sPool != null) {                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            }        }        return new Message();    }    public HandlerLite getTarget() {        return target;    }    public void setTarget(HandlerLite target) {        this.target = target;    }    /*package*/ boolean isInUse() {        return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);    }    /*package*/ void markInUse() {        flags |= FLAG_IN_USE;    }    public void recycle() {        if (isInUse()) {            if (gCheckRecycle) {                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;                        + &quot;is still in use.&quot;);            }            return;        }        recycleUnchecked();    }    void recycleUnchecked() {        // Mark the message as in use while it remains in the recycled object pool.        // Clear out all other details.        flags = FLAG_IN_USE;        what = 0;        arg1 = 0;        arg2 = 0;        obj = null;        when = 0;        target = null;        callback = null;        synchronized (sPoolSync) {            if (sPoolSize &lt; MAX_POOL_SIZE) {                next = sPool;                sPool = this;                sPoolSize++;            }        }    }    @Override    public String toString() {        return &quot;Message{&quot; +                &quot;what=&quot; + what +                &quot;, arg1=&quot; + arg1 +                &quot;, arg2=&quot; + arg2 +                &quot;, obj=&quot; + obj.toString() +                &quot;, when=&quot; + when +                &quot;, flags=&quot; + flags +                &quot;, target=&quot; + target +                &#39;}&#39;;    }}</code></pre><p>Message主要功能就是作为消息的载体并且提供了一个消息缓冲池，用来缓存Message 通过obtain方法我们可以获得缓冲池中的空闲Messag。同时它也提供了回收消息的方法recycleUnchecked，该方法会clear Message 的字段并放入消息缓冲池中。</p><p>最后就是MessageQueue了</p><pre><code>public class MessageQueue {    Message mMessages;    public MessageQueue() {    }    public Message next() {        int nextPollTimeoutMillis = 0;        for (; ; ) {            synchronized (this) {                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages;                if (msg != null &amp;&amp; msg.target == null) {                    Log.i(TAG, &quot;next: &quot; + msg.target);                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null);                }                if (msg != null) {                    if (now &lt; msg.when) {                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                        if (prevMsg != null) {                            Log.i(TAG, &quot;next pre: &quot; + prevMsg.toString());                            prevMsg.next = msg.next;                        } else {                            mMessages = msg.next;                        }                        msg.next = null;                        msg.markInUse();                        Log.i(TAG, &quot;next: &quot; + msg.toString());                        return msg;                    }                } else {                    // No more messages.                    nextPollTimeoutMillis = -1;                }            }        }    }    public boolean enQueueMessage(Message msg, long when) {        if (msg.target == null) {            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);        }        if (msg.isInUse()) {            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);        }        synchronized (this) {            msg.markInUse();            msg.when = when;            Message p = mMessages;            if (p == null || when == 0 || when &lt; p.when) {                msg.next = p;                mMessages = msg;            } else {                Message prev;                for (; ; ) {                    prev = p;                    p = p.next;                    if (p == null || when &lt; p.when) {                        break;                    }                }                msg.next = p; // invariant: p == prev.next                prev.next = msg;            }        }        return true;    }    void quit(boolean safe) {        synchronized (this) {            if (safe) {                removeAllFutureMessagesLocked();            } else {                removeAllMessagesLocked();            }        }    }    private void removeAllFutureMessagesLocked() {        final long now = SystemClock.uptimeMillis();        Message p = mMessages;        if (p != null) {            if (p.when &gt; now) {                removeAllMessagesLocked();            } else {                Message n;                for (; ; ) {                    n = p.next;                    if (n == null) {                        return;                    }                    if (n.when &gt; now) {                        break;                    }                    p = n;                }                p.next = null;                do {                    p = n;                    n = p.next;                    p.recycleUnchecked();                } while (n != null);            }        }    }    private void removeAllMessagesLocked() {        Message p = mMessages;        while (p != null) {            Message n = p.next;            p.recycleUnchecked();            p = n;        }        mMessages = null;    }    void removeCallbacksAndMessages(HandlerLite h, Object object) {        if (h == null) {            return;        }        synchronized (this) {            Message p = mMessages;            // Remove all messages at front.            while (p != null &amp;&amp; p.target == h                    &amp;&amp; (object == null || p.obj == object)) {                Message n = p.next;                mMessages = n;                p.recycleUnchecked();                p = n;            }            // Remove all messages after front.            while (p != null) {                Message n = p.next;                if (n != null) {                    if (n.target == h &amp;&amp; (object == null || n.obj == object)) {                        Message nn = n.next;                        n.recycleUnchecked();                        p.next = nn;                        continue;                    }                }                p = n;            }        }    }}</code></pre><p>MessageQueue是一个由链表实现的消息队列，Handler发送的消息都会存放到该队列中等待Looper取出。所以我们需要关注它的enQueueMessage和next，要熟悉并掌握对入队和出队过程。</p><p>至此我们简化版的Handler就完成了下面我们来测试下它是否能正常运行。</p><p>首先我们在项目的ExampleInstrumentedTest类的TestHandlerLite方法中调用Looper.prepare(); 即创建looper。<br>之后我们new 一个HandlerLite 并重写handleMessage方法在其中打印当前线程和发送消息的线程。</p><pre><code> final HandlerLite handlerLite=new HandlerLite(){            @Override            public void handleMessage(Message msg) {                super.handleMessage(msg);                System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getName()+&quot; 消息线程：   &quot;+msg.obj);            }        };</code></pre><p>然后new Thread 在run方法中通过obtain方法获取一个message并且其obj字段中存放的是当前线程名称然后通过handlerlite发送。</p><pre><code> new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    Message message = handlerLite.obtainMessage();                    message.obj = Thread.currentThread().getName();                    handlerLite.sendMessage(message);                }            }        }).start();</code></pre><p>最后一步就是在函数尾部调用Looper.loop 来让整个消息机制运转起来。</p><p>通过log我们可以看到消息是跨线程的。</p><pre><code>I/System.out: 当前线程：Instr: android.support.test.runner.AndroidJUnitRunner 消息线程：   Thread-2</code></pre><p>由此可以验证我们的简化版Handler运转正常。</p><p>最后贴下完整的验证代码</p><pre><code>public void TestHandlerLite() {        // Context of the app under test.        Context appContext = InstrumentationRegistry.getTargetContext();        assertEquals(&quot;com.robin.handlerlite&quot;, appContext.getPackageName());        Looper.prepare();        final HandlerLite handlerLite=new HandlerLite(){            @Override            public void handleMessage(Message msg) {                super.handleMessage(msg);                System.out.println(&quot;当前线程：&quot;+Thread.currentThread().getName()+&quot; 消息线程：   &quot;+msg.obj);            }        };        new Thread(new Runnable() {            @Override            public void run() {                while (true) {                    Message message = handlerLite.obtainMessage();                    message.obj = Thread.currentThread().getName();                    handlerLite.sendMessage(message);                }            }        }).start();        Looper.loop();    }</code></pre><p><a href="https://github.com/Robin132929/HandlerLite" target="_blank" rel="noopener">项目地址</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler三部曲(二)</title>
    <link href="/2019/08/11/Handler(%E4%BA%8C)/"/>
    <url>/2019/08/11/Handler(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>导读：上篇文章我们介绍了Handler的基本使用以及Handler机制调用流程的源码跟踪分析。这篇文章我们来详细的解析下Handler机制设计的4个类中都做了什么。</p><a id="more"></a><h1 id="Handler三部曲（二）"><a href="#Handler三部曲（二）" class="headerlink" title="Handler三部曲（二）"></a>Handler三部曲（二）</h1><h3 id="一、Handler"><a href="#一、Handler" class="headerlink" title="一、Handler"></a>一、Handler</h3><p>Handler主要负责消息的发送以及消息最终的处理。</p><p><strong>1、首先看下Handler内部常用的变量</strong></p><pre><code>  public class Handler {        /**         * Hanlder内部变量         */        private static android.os.Handler MAIN_THREAD_HANDLER = null; //表示主线程Hanlder实例        final Looper mLooper; //handler持有的looper对象        final MessageQueue mQueue; //handler持有的messagequeue对象 ，通过mLooper.mQueue为其赋值        final android.os.Handler.Callback mCallback;  //handler的callback    }</code></pre><p><strong>2、然后是Handler的构造函数，此处要说明的是Handler公开的构造函数有4种，另外还有3种属于hide，我们不可调用的。</strong></p><pre><code>   public class Handler {        /**         * Handler 构造函数前四种是可调用的，后面三种不可调用         */        public Handler() {            this(null, false);        }        public Handler(android.os.Handler.Callback callback) {            this(callback, false);        }        public Handler(Looper looper) {            this(looper, null, false);        }        public Handler(Looper looper, android.os.Handler.Callback callback) {            this(looper, callback, false);        }        public Handler(boolean async) {            this(null, async);        }        public Handler(android.os.Handler.Callback callback, boolean async) {            if (FIND_POTENTIAL_LEAKS) {                final Class&lt;? extends android.os.Handler&gt; klass = getClass();                if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                        (klass.getModifiers() &amp; Modifier.STATIC) == 0) {                    Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +                            klass.getCanonicalName());                }            }            mLooper = Looper.myLooper();//详见Looper类解析            if (mLooper == null) {                throw new RuntimeException(                        &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);            }            mQueue = mLooper.mQueue;            mCallback = callback;            mAsynchronous = async;        }        public Handler(Looper looper, android.os.Handler.Callback callback, boolean async) {            mLooper = looper;            mQueue = looper.mQueue;            mCallback = callback;            mAsynchronous = async;        }    }</code></pre><p>可以看出可调用的4种构造函数最终都是调用这两个构造函数</p><pre><code>Handler(android.os.Handler.Callback callback, boolean async) //方法6Handler(Looper looper, android.os.Handler.Callback callback, boolean async) //方法7</code></pre><p>这两个构造函数主要是为一些属性值进行赋值，包括mLooper、mQueue、mCallback等。</p><p><strong>3、接下来就是Handler定义的各种方法函数。这些函数常用的主要分为以下几类：发送消息相关函数、获取Message实例相关函数、移除消息。</strong></p><p><strong>先说发送消息相关函数，它包括send和post两种方式</strong></p><pre><code>  public class Handler {        /** 发送消息分为send和post两种         *         */        public final boolean sendMessage(Message msg)        {            return sendMessageDelayed(msg, 0);        }        public final boolean sendEmptyMessage(int what)        {            return sendEmptyMessageDelayed(what, 0);        }        public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {            Message msg = Message.obtain();            msg.what = what;            return sendMessageDelayed(msg, delayMillis);        }        public final boolean post(Runnable r)        {            return  sendMessageDelayed(getPostMessage(r), 0);        }        public final boolean postAtTime(Runnable r, long uptimeMillis)        {            return sendMessageAtTime(getPostMessage(r), uptimeMillis);        }        public final boolean postDelayed(Runnable r, long delayMillis)        {            return sendMessageDelayed(getPostMessage(r), delayMillis);        }        public final boolean sendMessageDelayed(Message msg, long delayMillis)        {            if (delayMillis &lt; 0) {                delayMillis = 0;            }            return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);        }        public boolean sendMessageAtTime(Message msg, long uptimeMillis) {            MessageQueue queue = mQueue;            if (queue == null) {                RuntimeException e = new RuntimeException(                        this + &quot; sendMessageAtTime() called with no mQueue&quot;);                Log.w(&quot;Looper&quot;, e.getMessage(), e);                return false;            }            return enqueueMessage(queue, msg, uptimeMillis);        }        private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);        }    }</code></pre><p>我们分析发现不管是send还是post最终都是调用的sendMessageAtTime，在sendMessageAtTime函数中会调用enqueueMessage，enqueueMessage中会调用MessageQueue的入队函数把msg入队。</p><pre><code> private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {        msg.target = this;        if (mAsynchronous) {            msg.setAsynchronous(true);        }        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><p><strong>获取Message相关函数</strong></p><pre><code>   public class Handler {        public final Message obtainMessage()        {            return Message.obtain(this);        }        public final Message obtainMessage(int what)        {            return Message.obtain(this, what);        }        public final Message obtainMessage(int what, Object obj)        {            return Message.obtain(this, what, obj);        }        public final Message obtainMessage(int what, int arg1, int arg2)        {            return Message.obtain(this, what, arg1, arg2);        }        public final Message obtainMessage(int what, int arg1, int arg2, Object obj)        {            return Message.obtain(this, what, arg1, arg2, obj);        }    }</code></pre><p>Handler的obtainMessage可以根据需求获取我们想要的Message实例而不用我们new一个Message实例。在实际的使用过程中更推荐通过obtainMessage方式获取Message这样效率更高。Handler的obtainMessage没有做任何操作都是调用的Message的obtain方法获取Message实例（关于Message的obtain方法 详见Message类解析）</p><p><strong>Handler的remove方法，该类方法可以帮助我们移除对应的message或callback。</strong></p><pre><code>public class Handler {        public final void removeCallbacks(Runnable r)        {            mQueue.removeMessages(this, r, null);        }        public final void removeCallbacks(Runnable r, Object token)        {            mQueue.removeMessages(this, r, token);        }        public final void removeMessages(int what) {            mQueue.removeMessages(this, what, null);        }        public final void removeMessages(int what, Object object) {            mQueue.removeMessages(this, what, object);        }        public final void removeCallbacksAndMessages(Object token) {            mQueue.removeCallbacksAndMessages(this, token);        }    }</code></pre><p>remove方法内部都是直接调用MessageQueue的remove方法（具体实现详见MessageQueue类解析）</p><p><strong>4、其他一些常用函数</strong></p><pre><code>    public class Handler {        /**         * Handle system messages here.         */        public void dispatchMessage(Message msg) {            if (msg.callback != null) {                handleCallback(msg);            } else {                if (mCallback != null) {                    if (mCallback.handleMessage(msg)) {                        return;                    }                }                handleMessage(msg);            }        }        public void handleMessage(Message msg) {        }        /**         * Callback interface you can use when instantiating a Handler to avoid         * having to implement your own subclass of Handler.         */        public interface Callback {            /**             * @param msg A {@link android.os.Message Message} object             * @return True if no further handling is desired             */            public boolean handleMessage(Message msg);        }    }</code></pre><p>dispatchMessage完成的是Handler对消息的分发处理，消息处理的优先级依次是Message。callback&gt;Handler.callback&gt;Handler handleMessage。</p><p><strong>至此我们对Handler类有了一个比较全面的认识。总结来说就是Handler通过构造函数为其内部变量赋值，然后通过obtainMessage获取Message，通过send/post方法发送Message（Runnable），通过remove方法移除queue中的Message，通过dispatchMessage、handleMessage去分发处理Message。</strong></p><p>Handler问题总结：</p><h3 id="二、Message"><a href="#二、Message" class="headerlink" title="二、Message"></a>二、Message</h3><p>Message在Handler机制中作用是作为消息的载体而存在。</p><p><strong>1、主要属性</strong></p><pre><code>   public final class Message {        //消息载体相关字段        public int what;        public int arg1;        public int arg2;        public Object obj;        /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0; //标记字段 标记Message是否正在使用        /*package*/ int flags;        /*package*/ long when; //Message触发的时间 MessageQueue中根据该字段对Message进行入队出对操作        /*package*/ Handler target;  //标记Message是由哪个Handler发送的        /*package*/ Runnable callback; //post发送消息时传入的Runnable        // sometimes we store linked lists of these things        /*package*/ android.os.Message next;  //作用是充当next指针        private static final Object sPoolSync = new Object();        private static android.os.Message sPool;  //Message 缓冲池        private static int sPoolSize = 0;  //Message 缓冲池大小        private static final int MAX_POOL_SIZE = 50;   //Message 缓冲池最大容量    }</code></pre><p>消息载体相关字段就是我们传输的内容。</p><p><strong>2、obtain获取Message函数</strong></p><pre><code>  public final class Message {        /**         * Message提供了很多obtain方法来获取Message实例         *         *          */        public static android.os.Message obtain() {            synchronized (sPoolSync) {//加锁 同步                if (sPool != null) { //如果sPool不为空即Message缓存池不空就从中取出一个Message                    android.os.Message m = sPool;                    sPool = m.next;                    m.next = null;                    m.flags = 0; // clear in-use flag                    sPoolSize--;//缓存池大小减一                    return m;                }            }            //如果缓存池为空则new 一个Message返回            return new android.os.Message();        }        public static android.os.Message obtain(android.os.Message orig) {            android.os.Message m = obtain();            m.what = orig.what;            m.arg1 = orig.arg1;            m.arg2 = orig.arg2;            m.obj = orig.obj;            m.replyTo = orig.replyTo;            m.sendingUid = orig.sendingUid;            if (orig.data != null) {                m.data = new Bundle(orig.data);            }            m.target = orig.target;            m.callback = orig.callback;            return m;        }        public static android.os.Message obtain(Handler h) {            android.os.Message m = obtain();            m.target = h;            return m;        }    }</code></pre><p>obtain方法有很多重载，这里只是列举了其中的几个。浏览源码我们发现众多的obtain函数都是通过obtain（）这个无参函数来获取Message实例，只不过之后还会对获得的Message实例的相关变量赋值。在obtain（）方法中会判断Message缓存池是否为空 不为空则取出一个缓存的Message返回，否则new一个Message返回。</p><p>在解析Handler类时我们发现了Handler类中有很多obtainMessage方法，只不过它们都是调用对应的Message的obtain方法。当时我们曾说推荐使用obtain方法获取Message，现在想必你这应该明白为什么了吧。</p><p><strong>3、Message回收相关函数</strong></p><pre><code>   public final class Message {        public void recycle() {            if (isInUse()) {                if (gCheckRecycle) {                    throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;                            + &quot;is still in use.&quot;);                }                return;            }            recycleUnchecked();        }        /**         * Recycles a Message that may be in-use.         * Used internally by the MessageQueue and Looper when disposing of queued Messages.         */        void recycleUnchecked() {            // Mark the message as in use while it remains in the recycled object pool.            // Clear out all other details.            flags = FLAG_IN_USE;            what = 0;            arg1 = 0;            arg2 = 0;            obj = null;            replyTo = null;            sendingUid = -1;            when = 0;            target = null;            callback = null;            data = null;            synchronized (sPoolSync) {                if (sPoolSize &lt; MAX_POOL_SIZE) {                    next = sPool;                    sPool = this;                    sPoolSize++;                }            }        }    }</code></pre><p>上面我们分析了obtain方法是如何获取Message的，现在就来看下使用完的Message是如何“回收”的。</p><p>由上面两个函数我们可知，Message的“回收”实际是在<br>recycleUnchecked函数中完成的，它首先会把Message的字段设置为默认值，然后判断当前缓存池大小是否超过MAX_POOL_SIZE（默认为50），如果未超过那么就会把该Message加入缓存池。</p><p>其实在跟踪Handler机制运行流程源码的时候我们遇到过该函数的调用在Looper.loop（）函数中最后是会调用Message.recycleUnchecked()来回收Message。</p><p><strong>Message类解析到此基本完成，总结一下就是Message主要承担了消息载体的作用，并且提供了obtain和recycle方法来获取和回收Message实例，毕竟Android系统是靠消息机制驱动的，当消息发送频繁时obtain和recycle可以有效提高效率节约资源。</strong></p><h3 id="三、MessageQueue"><a href="#三、MessageQueue" class="headerlink" title="三、MessageQueue"></a>三、MessageQueue</h3><p>MessageQueue在整个Handler机制中主要作用就是根据Message的触发时间（Message.when字段）入队和出队。</p><p><strong>1、构造函数及Filed</strong></p><pre><code> public final class MessageQueue {        Message mMessages; //队首Message可以理解为头指针        private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); //IdleHandler此处标注出来，后面会说        //唯一的构造函数        MessageQueue(boolean quitAllowed) {            mQuitAllowed = quitAllowed;//表示MessageQueue是否可退出            mPtr = nativeInit();//调用native 方法 此处暂时不做分析        }    }</code></pre><p>MessageQueue的构造函数比较简单，Filed我们只需要理解mMessages的作用就可以。关于IdleHandler，它是当MessageQueue为空或者空闲时会触发IdleHandler的queueIdle()方法，queueIdle会返回一个布尔值如果为false那么会移除对应的IdleHandler，否则在下次MessageQueue为空或者空闲时继续触发ueueIdle()。简单来说就是在MessageQueue没事做的时候触发完成一些操作，在LeakCanary，Glide等开源项目中都有用到。<a href="https://wetest.qq.com/lab/view/352.html" target="_blank" rel="noopener">具体可参考这篇文章，点我！！！</a></p><p><strong>2、入队</strong></p><pre><code>public final class MessageQueue {        boolean enqueueMessage(Message msg, long when) {            if (msg.target == null) { //msg的handler为空抛出异常                throw new IllegalArgumentException(&quot;Message must have a target.&quot;);            }            if (msg.isInUse()) {//当前msg正在被占用抛出异常                throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);            }            synchronized (this) {                if (mQuitting) {                    IllegalStateException e = new IllegalStateException(                            msg.target + &quot; sending message to a Handler on a dead thread&quot;);                    Log.w(TAG, e.getMessage(), e);                    msg.recycle();                    return false;                }                msg.markInUse();//设置msg被占用                msg.when = when;//msg的触发时间                Message p = mMessages;//队首指针                boolean needWake;                if (p == null || when == 0 || when &lt; p.when) {                //此处对应的三个条件：p == null 表示queue为空、when == 0 表示该消息无延迟需要即刻触发、when &lt; p.when 表示该msg的触发时间早于队首msg的触发时间                以上三种情况下直接把msg放在队首                    // New head, wake up the event queue if blocked.                    msg.next = p;                    mMessages = msg;                    needWake = mBlocked;                } else {                //不满足上面三种情况 就要根据when（触发时间）插入到MessageQueue合适位置                    // Inserted within the middle of the queue.  Usually we don&#39;t have to wake                    // up the event queue unless there is a barrier at the head of the queue                    // and the message is the earliest asynchronous message in the queue.                    needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();                    Message prev;                    for (; ; ) {                        prev = p;                        p = p.next;                        if (p == null || when &lt; p.when) {                            break;                        }                        if (needWake &amp;&amp; p.isAsynchronous()) {                            needWake = false;                        }                    }                    msg.next = p; // invariant: p == prev.next                    prev.next = msg;                }                // We can assume mPtr != 0 because mQuitting is false.                if (needWake) {                    nativeWake(mPtr);                }            }            return true;        }    }</code></pre><p>入队的过程注释已经很清楚了，此处就不再赘述，相信你看完肯定会明白。</p><p><strong>3、出队</strong></p><pre><code>    public final class MessageQueue {       Message next() {        // Return here if the message loop has already quit and been disposed.        // This can happen if the application tries to restart a looper after quit        // which is not supported.        final long ptr = mPtr;        if (ptr == 0) {            return null;        }        int pendingIdleHandlerCount = -1; // -1 only during first iteration        int nextPollTimeoutMillis = 0;        for (;;) { //死循环            if (nextPollTimeoutMillis != 0) {                Binder.flushPendingCommands();            }            nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) {                // Try to retrieve the next message.  Return if found.                final long now = SystemClock.uptimeMillis(); //当前时刻据开机时间点的毫秒数                Message prevMsg = null;                Message msg = mMessages;//队首Message                if (msg != null &amp;&amp; msg.target == null) {                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null &amp;&amp; !msg.isAsynchronous());                }                if (msg != null) { //Message不为空                    if (now &lt; msg.when) { //未到触发时间                        // Next message is not ready.  Set a timeout to wake up when it is ready.                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                         // Got a message. 从MessageQueue取出message，注意此处取出后消息队列会移除该Message，也就是该操作类似于pop                        mBlocked = false;                        if (prevMsg != null) {                            prevMsg.next = msg.next;                        } else {                            mMessages = msg.next;                        }                        msg.next = null;                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);                        msg.markInUse();                        return msg; //返回取出的msg                    }                } else {                    // No more messages. MessageQueue没有message                    nextPollTimeoutMillis = -1;                }                // Process the quit message now that all pending messages have been handled.                if (mQuitting) {                    dispose();                    return null;                }                // If first time idle, then get the number of idlers to run.                // Idle handles only run if the queue is empty or if the first message                // in the queue (possibly a barrier) is due to be handled in the future.                if (pendingIdleHandlerCount &lt; 0                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {                    pendingIdleHandlerCount = mIdleHandlers.size(); //此处获取已注册的IdleHandler                }                if (pendingIdleHandlerCount &lt;= 0) {                    // No idle handlers to run.  Loop and wait some more.                    mBlocked = true;                    continue;                }                if (mPendingIdleHandlers == null) {                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];                }                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);            }            // Run the idle handlers.            // We only ever reach this code block during the first iteration.            //遍历已注册的IdleHandler            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {                final IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = null; // release the reference to the handler                boolean keep = false;                try {                    keep = idler.queueIdle();//调用queueIdle()                } catch (Throwable t) {                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);                }                if (!keep) {                    synchronized (this) {                        mIdleHandlers.remove(idler);                    }                }            }            // Reset the idle handler count to 0 so we do not run them again.            pendingIdleHandlerCount = 0;            // While calling an idle handler, a new message could have been delivered            // so go back and look again for a pending message without waiting.            nextPollTimeoutMillis = 0;        }    }    }</code></pre><p>可以看出出队操作就是循环取出队首message，然后判断是否到了触发时间，如果到了就取出message并返回<br>，直到队列为空。当队列空的时候就会去获取注册的IdHandler列表，然后依次遍历调用queueIdle()方法。</p><p><strong>4、移除消息</strong></p><pre><code>void removeMessages(Handler h, int what, Object object) {            if (h == null) {                return;            }            synchronized (this) {                Message p = mMessages;                //这里分两种情况进行分析：                //1、MessageQueue队首不是要移除的message 此时不满足注释1处的判断条件且p= mMessages,然后走到注释2处取下一个message并在                // 注释3处判断是否是要移除的message，如果是则移除 否则继续遍历队列下一个message直到队尾 。                //2、MessageQueue队首是要移除的message，此时满足注释1的条件，删除message 并取下一个message继续判断是否满足移除条件，直                // 到队列移动到队首message不满足移除条件。然后走到注释2处继续遍历剩下的message 如果有满足条件的 移除，否则循环遍历直至队尾。                // Remove all messages at front.                while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what                        &amp;&amp; (object == null || p.obj == object)) {//1                    Message n = p.next;                    mMessages = n;                    p.recycleUnchecked();//消息的回收是通过我们之前分析的recycleUnchecked()完成的                    p = n;                }                // Remove all messages after front.                while (p != null) { //2                    Message n = p.next;                    if (n != null) { //3                        if (n.target == h &amp;&amp; n.what == what                                &amp;&amp; (object == null || n.obj == object)) {                            Message nn = n.next;                            n.recycleUnchecked();                            p.next = nn;                            continue;                        }                    }                    p = n;                }            }        }        void removeCallbacksAndMessages(Handler h, Object object) {            if (h == null) {                return;            }            synchronized (this) {                Message p = mMessages;                // Remove all messages at front.                while (p != null &amp;&amp; p.target == h                        &amp;&amp; (object == null || p.obj == object)) {                    Message n = p.next;                    mMessages = n;                    p.recycleUnchecked();                    p = n;                }                // Remove all messages after front.                while (p != null) {                    Message n = p.next;                    if (n != null) {                        if (n.target == h &amp;&amp; (object == null || n.obj == object)) {                            Message nn = n.next;                            n.recycleUnchecked();                            p.next = nn;                            continue;                        }                    }                    p = n;                }            }        }    }</code></pre><p>实际上有很多移除的方式不过本质大多是一样的，所以此处只贴了其中的两个。移除操作在上面的注释已经解释的很清楚了，不懂得跟着注释和代码自己对一遍就明白了。</p><h3 id="四、Looper"><a href="#四、Looper" class="headerlink" title="四、Looper"></a>四、Looper</h3><p><strong>1、构造函数和Filed</strong></p><pre><code>  public final class Looper {        // sThreadLocal.get() will return null unless you&#39;ve called prepare().        static final ThreadLocal&lt;android.os.Looper&gt; sThreadLocal = new ThreadLocal&lt;android.os.Looper&gt;();//ThreadLocal是一个线程隔离的本地存储工具，此处使用ThreadLocal是用来存储Looper对象的        private static android.os.Looper sMainLooper;  // 主线程的Looper guarded by Looper.class        final MessageQueue mQueue; //Looper持有queue        final Thread mThread; //Looper所在线程        private Looper(boolean quitAllowed) {            mQueue = new MessageQueue(quitAllowed);            mThread = Thread.currentThread();        }    }</code></pre><p>Looper构造函数中new了一个Message并赋值给queue，另外还获取了当前所在线程。ThreadLocal是用来存储每个线程的Looper对象的，并且每个线程只能有一个Looper对象，Looper对象的存储和获取是通过下面方法完成的。有关ThreadLocal更深入的知识以后有时间在介绍。</p><p>Looper创建、存储是通过prepare完成的，具体来说就是new一个Looper实例然后通过ThreadLocal的set方法存储起来。</p><pre><code>public static void prepare() {        prepare(true);    }    private static void prepare(boolean quitAllowed) {        if (sThreadLocal.get() != null) {//每个线程只能有一个Looper 在prepare时会检测当前线程是否已经有了Looper 如果get()不为空 则抛出异常            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        }        sThreadLocal.set(new Looper(quitAllowed));    }</code></pre><p>Looper的获取则是在myLooper（），它是通过ThreadLocal<br>.get获取到的</p><pre><code> public static @Nullable Looper myLooper() {        return sThreadLocal.get();    }</code></pre><p>此处需要注意的是在每个线程中在使用Handler发送message之前必须先调用Looper.prepaer(),并且在适当位置调用Looper.loop（）。</p><p>比如这样</p><pre><code>class LooperThread extends Thread {            public Handler mHandler;            public void run() {                Looper.prepare();                mHandler = new Handler() {                    public void handleMessage(Message msg) {                        // process incoming messages here                    }                };                Looper.loop();            }        }</code></pre><p>有人可能会疑惑主线程是什么时候调用 Looper.prepare()的。解释这个问题我们先来回想下一般我们写的Java程序是否都会有一个main函数作为入口，Android 石油Java实现的那这个入口在哪呢。</p><p>浏览源码我们可知这个入口就是ActivityThread的main函数</p><pre><code> public static void main(String[] args) {        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);        // CloseGuard defaults to true and can be quite spammy.  We        // disable it here, but selectively enable it later (via        // StrictMode) on debug builds, but using DropBox, not logs.        CloseGuard.setEnabled(false);        Environment.initForCurrentUser();        // Set the reporter for event logging in libcore        EventLogger.setReporter(new EventLoggingReporter());        // Make sure TrustedCertificateStore looks in the right place for CA certificates        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());        TrustedCertificateStore.setDefaultUserDirectory(configDir);        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);        //主线程looper        Looper.prepareMainLooper();        //创建主线程        ActivityThread thread = new ActivityThread();        //调用attach 创建application         thread.attach(false);        if (sMainThreadHandler == null) {            sMainThreadHandler = thread.getHandler();        }        if (false) {            Looper.myLooper().setMessageLogging(new                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));        }        //为了便于理解 ，我们假定现在是从子线程发消息给主线程（UI线程）经过上面的分析此时Message已经从子线程发出并送到MessageQueue        //此时在主线程执行Looper.loop 便可以将MessageQueue中的Message取出并分发 loop首先获得一个 之后进入一个无限循环中 不断调用MessageQueue的next方法        //next方法的主要作用是从MessageQueue中取出Messade        //最后调用handler的dispatchMessage分发Message  在dispatchMessage方法中进行Message的处理 首先会判断该Message的callback是否为空        // 如果为空 则判断handler的callback是否为空 如果handler的callback为空才会执行handleMessage 该方法就是我们重写的handleMessage方法        // 至此我们回到主线程        // End of event ActivityThreadMain.        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        //开启looper        Looper.loop();        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);    }</code></pre><p>我们看到在ActivityThread的main函数中先是调用了Looper.prepareMainLooper()准备好Looper，然后获取sMainThreadHandler（主线程Handler）最后调用了Looper.loop（）。所以我们在主线程无需自己手动prepare，Android系统已经帮我们prepare了。</p><p><strong>2、loop</strong></p><pre><code>public static void loop() {        final Looper me = myLooper(); //获取Looper对象        if (me == null) {            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);        }        final MessageQueue queue = me.mQueue;        // Make sure the identity of this thread is that of the local process,        // and keep track of what that identity token actually is.        Binder.clearCallingIdentity();        final long ident = Binder.clearCallingIdentity();        for (;;) { //死循环            Message msg = queue.next(); // might block 取一条message 这里可能会阻塞            if (msg == null) {                // No message indicates that the message queue is quitting.                return;            }            // This must be in a local variable, in case a UI event sets the logger            final Printer logging = me.mLogging;            if (logging != null) {                logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                        msg.callback + &quot;: &quot; + msg.what);            }            final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;            final long traceTag = me.mTraceTag;            if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));            }            final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            final long end;            try {                msg.target.dispatchMessage(msg); //通过message持有的handler分发消息                end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();            } finally {                if (traceTag != 0) {                    Trace.traceEnd(traceTag);                }            }            if (slowDispatchThresholdMs &gt; 0) {                final long time = end - start;                if (time &gt; slowDispatchThresholdMs) {                    Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;                            + Thread.currentThread().getName() + &quot;, h=&quot; +                            msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);                }            }            if (logging != null) {                logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);            }            // Make sure that during the course of dispatching the            // identity of the thread wasn&#39;t corrupted.            final long newIdent = Binder.clearCallingIdentity();            if (ident != newIdent) {                Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                        + Long.toHexString(ident) + &quot; to 0x&quot;                        + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                        + msg.target.getClass().getName() + &quot; &quot;                        + msg.callback + &quot; what=&quot; + msg.what);            }            msg.recycleUnchecked(); //回收消息        }    }</code></pre><p>loop就是循环的取message然后分发出去，然后把消息回收。要注意的点就是queue.next()是可能会阻塞的。</p><p><strong>以上就是Handler机制涉及的四个类，这里还是推荐大家看完文章自己在读一遍源码。下篇文章我会带大家手写一个简化版的Handler</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler三部曲(一)</title>
    <link href="/2019/07/29/Handler/"/>
    <url>/2019/07/29/Handler/</url>
    
    <content type="html"><![CDATA[<h1 id="Handler三部曲（一）"><a href="#Handler三部曲（一）" class="headerlink" title="Handler三部曲（一）"></a>Handler三部曲（一）</h1><p>Handler是Android重要的消息分发机制，这就要求我们不仅会正确使用更要了解熟悉其内部实现。该系列共分为三步：</p><p>1、首先带大家了解Handler的基本使用以及Handler消息分发流程的源码，这可以帮助我们对Handler机制有一个大致了解。</p><p>2、然后是详细的解析Handler机制涉及的四个类帮我们更加深入了解Handler机制。</p><p>3、最后就是动手实践。网上大多数文章只是带大家分析源码，俗话说纸上得来终觉浅所以我会带大家手写一个简略版的Handler。</p><p><strong>阅读建议：推荐看完前两步之后自己独立的去阅读一遍源码，然后再看第三步手写Handler</strong></p><p>本篇文章是Hadler三部曲的第一步，主要是介绍Handler的基本使用以及Handler消息分发流程的源码让大家对Handler有一个基本的认识。</p><h3 id="一、Handler使用"><a href="#一、Handler使用" class="headerlink" title="一、Handler使用"></a>一、Handler使用</h3><p>一般使用流程如下：</p><pre><code>//首先获取一个handler并重写handleMessage方法 此处打印当前线程名以及消息来源线程名public Handler handler = new Handler() {@Overridepublic void handleMessage(Message msg) {super.handleMessage(msg);// do something...switch (msg.what) {case 10000:Log.i(TAG, &quot;handleMessage: &quot; + &quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;   获得 &quot; + msg.obj.toString() + &quot; 线程传来的消息&quot;);break;default:break;}}};//在子线程发送messagenew Thread(new Runnable() {@Overridepublic void run() {Object obj = Thread.currentThread().getName();Message msg = handler.obtainMessage(10000, obj);handler.sendMessage(msg); }}).start();//还可以使用post（postdelay）handler.post(new Runnable() {@Overridepublic void run() {//此处打印当前线程Log.i(TAG, &quot;post: &quot; + &quot;当前线程：&quot; + Thread.currentThread().getName());}});</code></pre><p>++注：上面写法实际是存在内存泄漏的风险的，后面会讲++</p><p>由上面代码可知handler主要有两个用途：</p><p>1、让message或runnable在将来某个时刻执行</p><p>2、在与自己不同的线程执行某种操作</p><h3 id="二、Handler-解析"><a href="#二、Handler-解析" class="headerlink" title="二、Handler 解析"></a>二、Handler 解析</h3><h5 id="Handler涉及的四个主要类"><a href="#Handler涉及的四个主要类" class="headerlink" title="Handler涉及的四个主要类"></a>Handler涉及的四个主要类</h5><ul><li>Handler 线程间通信的工具类 可以用来发送消息或任务</li><li>Message 要发送的消息或任务</li><li>MessageQueue 存放Message的队列 实际是一个链表结构</li><li>Looper 类似一个轮询器 不断的从MessageQueue中取Message并分发</li></ul><h5 id="Handler-执行流程源码解析"><a href="#Handler-执行流程源码解析" class="headerlink" title="Handler 执行流程源码解析"></a>Handler 执行流程源码解析</h5><p><strong>源码解析</strong>：我们以sendMessage方法为入口跟进源码</p><p><strong>1.sendMessage调用sendMessageDelayed并将msg 和0 传入</strong></p><pre><code>public final boolean sendMessage(Message msg){return sendMessageDelayed(msg, 0);}</code></pre><p><strong>2.sendMessageDelayed 对传入的delayMillis做了下判断 如果小于0 则默认为0。 此处的delayMillis其实就是该消息发出时间 最后调用sendMessageAtTime 此处的SystemClock.uptimeMillis()代表从开机到当前时刻的毫秒数</strong></p><pre><code>public final boolean sendMessageDelayed(Message msg, long delayMillis){if (delayMillis &lt; 0) {delayMillis = 0;}return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); }</code></pre><p><strong>3.handler其实提供了很多种发送message的方法。（如post等等） 它们最终会走到sendMessageAtTime函数这里 我们看到它首先判断了queue是否为空，即mQueue是否为空，mQueue赋值是在调用Handler时赋值的。然后该方法最终会调用enqueueMessage方法</strong></p><pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {MessageQueue queue = mQueue;if (queue == null) {RuntimeException e = new RuntimeException(this + &quot; sendMessageAtTime() called with no mQueue&quot;);Log.w(&quot;Looper&quot;, e.getMessage(), e);return false;}return enqueueMessage(queue, msg, uptimeMillis);}</code></pre><p><strong>4.enqueueMessage最终会将发送的message送入MessageQueue</strong></p><pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {msg.target = this;if (mAsynchronous) {msg.setAsynchronous(true);}return queue.enqueueMessage(msg, uptimeMillis);}</code></pre><p><strong>5.MessageQueue实际是一个链表结构，MessageQueue中有个mMessages变量 它本身是一个Message实例 定义这样一个变量的作用是标识MessageQueue位于表头的Message。 在enqueueMessage方法中 将mMessages赋值给p 此时p即代表了链表头的message 然后会对p做一些判断 即是否为空（如为空则说明此时MessageQueue为空）、when是否为0（如为0代表该消息无需延迟发出）、传入的message的when时间是否早于当前链表头message的when时间 如果满足上述条件之一则将传入的msg插入链表头 否则就会遍历MessageQueue链表根据when属性找到 msg在链表中的合适位置并插入链表 至此message的“入队操作完成”</strong></p><pre><code>boolean enqueueMessage(Message msg, long when) {//...msg.markInUse();msg.when = when;Message p = mMessages;boolean needWake;if (p == null || when == 0 || when &lt; p.when) {// New head, wake up the event queue if blocked.msg.next = p;mMessages = msg;needWake = mBlocked;} else {// Inserted within the middle of the queue.  Usually we don&#39;t have to wake// up the event queue unless there is a barrier at the head of the queue// and the message is the earliest asynchronous message in the queue.needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();Message prev;for (;;) {prev = p;p = p.next;if (p == null || when &lt; p.when) {break;}if (needWake &amp;&amp; p.isAsynchronous()) {needWake = false;}}msg.next = p; // invariant: p == prev.nextprev.next = msg;}// We can assume mPtr != 0 because mQuitting is false.if (needWake) {nativeWake(mPtr);}}return true;}</code></pre><p><strong>6.Message的发送和“入队”操作均完成后就是Message的“出队”以及分发。该操作是由Looper完成的，下面我们来分析Looper是如何将消息从MessageQueue中取出并将消息分发的 实际上是通过Looper.loop（）来实现Message出队和分发。下面我们一起来看下loop方法 首先它会调用myLooper方法获取一个looper对象（详见7） 然后会进入一个死循环中 不断的调用queue.next（详见8）从MessageQueue中取Message 最后如果取出的Message不为null 则调用msg.target.dispatchMessage分发消息（详见9）即 7、8、9便是Message的“出队”和分发</strong></p><pre><code>public static void loop() {final Looper me = myLooper(); //详见7if (me == null) {throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);}final MessageQueue queue = me.mQueue;for (;;) {Message msg = queue.next(); // might block 详见8if (msg == null) {// No message indicates that the message queue is quitting.return;}//...try {msg.target.dispatchMessage(msg); //详见9end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();} finally {if (traceTag != 0) {Trace.traceEnd(traceTag);}}//...msg.recycleUnchecked();//message回收}}</code></pre><p><strong>7.loop方法调用的myLooper来获得一个looper对象 关于此处如何得到的looper对象 后面在Looper类解析时会详细讲</strong></p><pre><code>public static @Nullable Looper myLooper() {return sThreadLocal.get();}</code></pre><p>*<em>8.拿到looper之后就调用MessageQueue的next方法 该方法同样是一个死循环 会不断的从MessageQueue中取Message然后返回 *</em></p><pre><code>Message next() {//...for (;;) {synchronized (this) {// Try to retrieve the next message.  Return if found.final long now = SystemClock.uptimeMillis();Message prevMsg = null;Message msg = mMessages;if (msg != null &amp;&amp; msg.target == null) {//一般通过obtain拿到的message其target均不为空,所以该处判断不成立// Stalled by a barrier.  Find the next asynchronous message in the queue.do {prevMsg = msg;msg = msg.next;} while (msg != null &amp;&amp; !msg.isAsynchronous());}if (msg != null) {//执行此处逻辑if (now &lt; msg.when) {//now&lt;msg.when表示msg的触发时间还未到// Next message is not ready.  Set a timeout to wake up when it is ready.nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);} else {// Got a message.mBlocked = false;if (prevMsg != null) {prevMsg.next = msg.next;} else {mMessages = msg.next;//取下一条msg}msg.next = null;//把该message从queue移除if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);msg.markInUse();return msg;}} else {// No more messages.nextPollTimeoutMillis = -1;}}}}</code></pre><p>*<em>9.获取到Message后进行消息分发。因为Message中有个target属性 它是一个handler对象 所以msg.target.dispatchMessage实际是调用handler中的dispatchMessage方法。 在dispatchMessage方法中 首先会判断该Message和handler的callback是否为空 如果两者都为空 才会执行重写的handleMessage方法 还记得handler可以使用post方式发送消息吗 使用post方式会传入一个Runnable对象 这个对象会赋值给Message的callback（callback是在Message中定义的一个Runnable对象）至此我们就可以在==handler所在线程==对收到的消息进行处理 *</em></p><pre><code>public void dispatchMessage(Message msg) {if (msg.callback != null) {handleCallback(msg);//如果message的callback 不为空优先执行} else {if (mCallback != null) {if (mCallback.handleMessage(msg)) {//如果handler的callback不为空 执行return;}}handleMessage(msg); //优先级最低 只有前面两个callback为空时才会执行到这里}}</code></pre><p>以上是使用Handler发送、Message入队、出队以及Message分发的整个运行过程。其中Handler负责消息的发送以及最终的处理，Message是消息的载体，MessageQueue完成消息进行入队和出队，Looper则通过轮询让整个过程运转起来完成消息传递的功能。下面贴一张Handler机制运行图</p><p><img src="http://gityuan.com/images/handler/handler_java.jpg" srcset="/img/loading.gif" alt="一张图"></p><p><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">图片来源：Android消息机制1-Handler(Java层)</a></p><h3 id="三、相关问题汇总："><a href="#三、相关问题汇总：" class="headerlink" title="三、相关问题汇总："></a>三、相关问题汇总：</h3><p>1、如何正确使用Handler方法避免内存泄漏</p><p>文章一开始我贴了一段我们一般使用Handler的代码，当时提示了那种使用方式是存在内存泄漏的风险的。那么什么情况会发生内存泄漏呢？我们都知道Handler可以通过post方法发送延迟执行的消息，而文首的使用方式Handler是持有Activity的引用的，如果在延迟消息执行前Activity销毁了，那么就会导致Activity的泄漏。解决方法就是可以使用静态内部类、弱应用、Activity销毁时及时清除消息。</p><pre><code>public class MainActivity extends AppCompatActivity {private RHandler mHandler = new RHandler(this);@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);}static class RHandler extends Handler {private WeakReference&lt;Activity&gt; mReference; //弱引用持有activityRHandler(Activity reference) {mReference = new WeakReference&lt;&gt;(reference);}@Overridepublic void handleMessage(Message msg) {//在这里拿到activty的引用 然后可以调用activity的相关方法MainActivity activity = (MainActivity) mReference.get();//dosmoething}}@Overrideprotected void onDestroy() {mHandler.removeCallbacksAndMessages(null);//activity销毁及时清除消息super.onDestroy();}}</code></pre><p><strong>2、Message触发时间为什么采用SystemClock.uptimeMillis()而不使用 System.currentTimeMillis()获得的时间</strong></p><p>搞清这个问题首先需要了解这两种获取时间的方式的差异。SystemClock.uptimeMillis()获取的是从开机到现在时刻的毫秒数 。System.currentTimeMillis()获取的是UTC时间的毫秒数。</p><p>Message触发时间采用uptimeMillis()的原因是用户可以手动修改时间，如果采用currentTimeMillis()那Message的触发会变得非常混乱。</p><p>了解了Hanlder整个运行流程之后我们再来详细的解析下每个类       未完待续…</p>]]></content>
    
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/07/29/hello-world/"/>
    <url>/2019/07/29/hello-world/</url>
    
    <content type="html"><![CDATA[<br><h1 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h1><p>关于写博客心心念了很久，之前也零星写了一些，不过写的是真实的烂。今天花了点时间简单搞了这个博客，希望自己能坚持下去。</p><p>关于这个博客目前的想法是会加一些 ==杂七乱八== 的而不是仅仅写一些跟IT相关的，毕竟除了工作还有很多值得我们记录的人和事。</p><p>关于更新，初期可能会把之前写的逐步放上来 更新频率不定，不过会尽量保证稳定输出。</p><p>I konw nothing but I can learn.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>